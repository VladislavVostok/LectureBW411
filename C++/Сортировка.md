
Сортировка — это процесс упорядочивания элементов в массиве или списке по определенному критерию (например, по возрастанию или убыванию). В программировании это одна из базовых задач, которая помогает эффективно искать, обрабатывать и анализировать данные. 

### Введение в алгоритмы сортировки

Существует несколько способов сортировки данных. Основные алгоритмы можно разделить на две категории:

1. **Простые алгоритмы сортировки**: Пузырьковая сортировка, сортировка выбором, сортировка вставками.

2. **Эффективные алгоритмы сортировки**: Быстрая сортировка, сортировка слиянием, сортировка кучей.


Каждый из этих алгоритмов подходит для разных типов задач. Простые алгоритмы легко реализуются, но имеют худшую производительность для больших наборов данных. Эффективные алгоритмы более сложные, но гораздо быстрее обрабатывают большие объемы данных.



#### Сортировка пузырьком (Bubble Sort)

**Принцип работы**: Этот алгоритм работает путем многократного прохода по массиву и сравнения соседних элементов. Если два элемента расположены в неправильном порядке, они меняются местами. Процесс повторяется до тех пор, пока массив не окажется отсортированным.

### Шаги:

1. Сравниваем два соседних элемента.
    
2. Если они находятся в неправильном порядке (например, первый больше второго), меняем их местами.
    
3. Повторяем шаги 1 и 2 до конца массива.
    
4. Повторяем весь процесс несколько раз, пока не произойдут больше ни одной перестановки.
    

**Код на C++:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

void bubbleSort(vector<int>& numbers) {
    int n = numbers.size();
    for (int i = 0; i < n; i++) {
        bool swapped = false; // Флаг, чтобы проверить, был ли обмен

        // Проходим по неотсортированной части массива
        for (int j = 0; j < n - i - 1; j++) {
            if (numbers[j] > numbers[j + 1]) {
                // Меняем местами элементы
                swap(numbers[j], numbers[j + 1]);
                swapped = true; // Устанавливаем флаг, если был обмен
            }
        }

        // Если обменов не было, массив уже отсортирован
        if (!swapped) {
            break;
        }
    }
}

int main() {
    vector<int> numbers = {64, 34, 25, 12, 22, 11, 90};

    cout << "Исходный массив: ";
    for (int num : numbers) {
        cout << num << " ";
    }
    cout << endl;

    bubbleSort(numbers);

    cout << "Отсортированный массив: ";
    for (int num : numbers) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}

```

**Временная сложность**: O(n^2) в худшем и среднем случаях. В лучшем случае (если массив уже отсортирован) — O(n).  
**Пространственная сложность**: O(1), так как сортировка происходит на месте (без использования дополнительной памяти).

Преимущество: Простой в реализации.  
Недостаток: Низкая производительность для больших массивов.


### **. Временная сложность (Time Complexity)**

- **Определение**: Количество операций, которое алгоритм выполняет в зависимости от размера входных данных.
- **Цель**: Оценить, как быстро алгоритм работает.
- **Мера**: Выражается в виде функции от размера входных данных nnn (например, O(1), O(n), O(n^2), O(log⁡ n).
- **Зависимость от входных данных**:
    - Оценивается число итераций циклов, рекурсивных вызовов или других действий, зависящих от количества данных.
- **Пример**:
    - У алгоритма пузырьковой сортировки временная сложность O(n^2), так как он сравнивает элементы nnn раз для nnn элементов.

---

### **2. Пространственная сложность (Space Complexity)**
- **Определение**: Количество памяти, которое алгоритм использует во время выполнения в зависимости от размера входных данных.
- **Цель**: Оценить, насколько эффективно алгоритм использует память.
- **Мера**: Также выражается как функция от размера входных данных nnn (например, O(1), O(n), O(n^2), O(log ⁡n).
- **Зависимость от алгоритма**:
    - Учитывается память для хранения входных данных, вспомогательных структур данных (массивов, стеков, очередей) и вызовов функций.
- **Пример**:
    - У рекурсивного алгоритма вычисления факториала временная сложность O(n), а пространственная — также O(n) так как каждый рекурсивный вызов требует выделения памяти для хранения состояния функции.

---

### **Ключевые отличия**

|**Критерий**|**Временная сложность**|**Пространственная сложность**|
|---|---|---|
|**Что измеряет**|Количество операций алгоритма|Количество памяти, занимаемой алгоритмом|
|**Единица измерения**|Операции (циклы, сравнения, вызовы функций)|Блоки памяти (переменные, массивы, структуры)|
|**Важность**|Показывает, насколько быстро работает алгоритм|Показывает, насколько эффективно используется память|
|**Пример (сортировка)**|Количество перестановок элементов|Память для временного хранения элементов|
|**Пример (рекурсия)**|Количество рекурсивных вызовов|Память для хранения стека вызовов функций|

---

### **Пример сравнения**

**Быстрая сортировка (Quicksort)**:

- **Временная сложность**: O(n log ⁡n) в среднем случае.
- **Пространственная сложность**: O(log⁡n)O(\log n)O(logn) из-за рекурсивного использования стека вызовов.

**Пузырьковая сортировка (Bubble Sort)**:

- **Временная сложность**: O(n^2) в худшем случае.
- **Пространственная сложность**: O(1), так как она использует память только для входного массива.

#### Сортировка вставками (Insertion Sort)

**Принцип работы**: Вставка каждого элемента массива в отсортированную часть массива, сдвигая элементы, которые больше текущего.

### Шаги:

1. Берем текущий элемент и сравниваем его с элементами слева от него.
    
2. Вставляем его в нужное место, сдвигая остальные элементы вправо.
    

**Код на C++:**

```cpp
#include <iostream>
#include <vector>
using namespace std;

void insertionSort(vector<int>& numbers) {
    int n = numbers.size(); // Получаем размер массива

    // Цикл для каждого элемента массива, начиная со второго
    for (int i = 1; i < n; i++) {
        int key = numbers[i]; // Ключевой элемент, который нужно вставить в отсортированную часть
        int j = i - 1; // Индекс последнего элемента отсортированной части

        // Перемещаем элементы, которые больше ключевого, на одну позицию вперед
        while (j >= 0 && numbers[j] > key) { // Пока не достигли начала массива и текущий элемент больше ключа
            numbers[j + 1] = numbers[j]; // Сдвигаем элемент на одну позицию вперед
            j--; // Переходим к предыдущему элементу
        }

        // Вставляем ключевой элемент на его правильное место
        numbers[j + 1] = key; // Размещаем ключевой элемент после всех элементов, которые были сдвинуты
    }
}


int main() {
    vector<int> numbers = {12, 11, 13, 5, 6};

    cout << "Исходный массив: ";
    for (int num : numbers) {
        cout << num << " ";
    }
    cout << endl;

    insertionSort(numbers);

    cout << "Отсортированный массив: ";
    for (int num : numbers) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}

```

**Временная сложность**: O(n^2) в худшем и среднем случаях. В лучшем случае (если массив уже отсортирован) — O(n).  
**Пространственная сложность**: O(1).

Преимущество: Хорошо работает на небольших массивах и почти отсортированных данных.  
Недостаток: Низкая производительность для больших массивов.


#### Быстрая сортировка (Quick Sort)

**Принцип работы**: Выбирается опорный элемент (pivot), массив разделяется на две части: элементы, меньшие чем pivot, и элементы, большие чем pivot. Затем рекурсивно сортируются обе части.

### Шаги:

1. Выбираем опорный элемент (например, последний элемент массива).
    
2. Разбиваем массив на две части: элементы меньше опорного и элементы больше опорного.
    
3. Рекурсивно сортируем обе части.

**Код на C++:**

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Функция для быстрой сортировки
vector<int> quickSort(const vector<int>& numbers) {
    if (numbers.size() < 2) { 
        return numbers; // Базовый случай: если массив состоит из 0 или 1 элемента, он уже отсортирован
    }

    // Выбираем опорный элемент (pivot)
    int pivot = numbers[numbers.size() / 2]; // Опорный элемент выбирается как элемент из середины массива
    vector<int> left, right; // Два массива для элементов, меньших и больших опорного

    // Разделение элементов на меньше и больше опорного
    for (int num : numbers) { // Проходим по всем элементам массива
        if (num < pivot) { 
            left.push_back(num); // Добавляем элементы, меньшие опорного, в массив left
        } else if (num > pivot) { 
            right.push_back(num); // Добавляем элементы, большие опорного, в массив right
        }
        // Равные pivot элементы игнорируются, так как они автоматически включатся позже
    }

    // Рекурсивная сортировка левой и правой частей, добавление опорного элемента
    vector<int> sortedLeft = quickSort(left); // Рекурсивно сортируем левую часть
    vector<int> sortedRight = quickSort(right); // Рекурсивно сортируем правую часть

    // Слияние отсортированных частей
    sortedLeft.push_back(pivot); // Добавляем опорный элемент в конец отсортированной левой части
    sortedLeft.insert(sortedLeft.end(), sortedRight.begin(), sortedRight.end()); // Добавляем отсортированную правую часть

    return sortedLeft; // Возвращаем результат: объединенный отсортированный массив
}


int main() {
    vector<int> numbers = {10, 7, 8, 9, 1, 5};

    cout << "Исходный массив: ";
    for (int num : numbers) {
        cout << num << " ";
    }
    cout << endl;

    // Сортировка массива
    vector<int> sortedNumbers = quickSort(numbers);

    cout << "Отсортированный массив: ";
    for (int num : sortedNumbers) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}


```

- **Базовый случай**:
    - Если длина массива меньше 2, он возвращается как есть, поскольку он уже отсортирован.
- **Опорный элемент (`pivot`)**:
    - Выбирается элемент из середины массива: `numbers[numbers.size() / 2]`.
- **Разделение массива**:
    - Все элементы, меньшие `pivot`, помещаются в массив `left`.
    - Все элементы, большие `pivot`, помещаются в массив `right`.
- **Рекурсивная сортировка**:
    - Левые и правые части сортируются отдельно с помощью рекурсивного вызова `quickSort`.
- **Слияние частей**:
    - Опорный элемент добавляется между отсортированными левой и правой частями.


**Временная сложность**: O(n log n) в среднем, O(n^2) в худшем случае (если выбор опорного элемента неудачен).  
**Пространственная сложность**: O(log n) из-за рекурсии.

Преимущество: Очень быстрый для больших массивов.  
Недостаток: В худшем случае может иметь плохую производительность.


#### Сортировка слиянием (Merge Sort)

**Принцип работы**: Массив рекурсивно делится на две части, каждая из которых сортируется, а затем сливаются в один отсортированный массив.

### Шаги:

1. Разбиваем массив на две половины.
2. Рекурсивно сортируем обе половины.
3. Сливаем отсортированные половины в один отсортированный массив.


**Код на Go:**
```cpp
#include <iostream>
#include <vector>

using namespace std;

// Функция для слияния двух отсортированных частей
vector<int> merge(const vector<int>& left, const vector<int>& right) {
    vector<int> result; // Вектор для хранения результата слияния
    int i = 0, j = 0;   // Индексы для итерации по массивам left и right

    // Сливаем два массива, сравнивая их элементы
    while (i < left.size() && j < right.size()) { // Пока есть элементы в обоих массивах
        if (left[i] < right[j]) { // Если текущий элемент из left меньше
            result.push_back(left[i]); // Добавляем его в результат
            i++; // Переходим к следующему элементу в left
        } else { // Если текущий элемент из right меньше или равен
            result.push_back(right[j]); // Добавляем его в результат
            j++; // Переходим к следующему элементу в right
        }
    }

    // Добавляем оставшиеся элементы из left, если они остались
    while (i < left.size()) {
        result.push_back(left[i]); // Добавляем элемент из left в результат
        i++; // Переходим к следующему элементу
    }

    // Добавляем оставшиеся элементы из right, если они остались
    while (j < right.size()) {
        result.push_back(right[j]); // Добавляем элемент из right в результат
        j++; // Переходим к следующему элементу
    }

    return result; // Возвращаем результат слияния
}

// Функция сортировки слиянием
vector<int> mergeSort(const vector<int>& numbers) {
    if (numbers.size() < 2) { // Базовый случай: если массив состоит из 0 или 1 элемента
        return numbers; // Он уже отсортирован, возвращаем его
    }

    int mid = numbers.size() / 2; // Находим середину массива

    // Разделяем массив на левую и правую части
    vector<int> left(numbers.begin(), numbers.begin() + mid); // Создаем вектор из первой половины массива
    vector<int> right(numbers.begin() + mid, numbers.end());  // Создаем вектор из второй половины массива

    // Рекурсивная сортировка левой части
    left = mergeSort(left);

    // Рекурсивная сортировка правой части
    right = mergeSort(right);

    // Слияние отсортированных частей
    return merge(left, right); // Возвращаем объединенный отсортированный массив
}


int main() {
    vector<int> numbers = {38, 27, 43, 3, 9, 82, 10};

    cout << "Исходный массив: ";
    for (int num : numbers) {
        cout << num << " ";
    }
    cout << endl;

    // Сортировка массива
    vector<int> sortedNumbers = mergeSort(numbers);

    cout << "Отсортированный массив: ";
    for (int num : sortedNumbers) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
```

### Объяснение:

1. **Базовый случай**:
    - Если размер массива меньше 2, он возвращается как есть, потому что массив из 0 или 1 элемента уже отсортирован.
2. **Разделение массива**:
    - Массив делится на две части: `left` и `right`. Для этого используются итераторы `begin()` и `end()`.
3. **Рекурсивная сортировка**:
    - Для каждой части вызывается `mergeSort` рекурсивно.
4. **Слияние**
    - Две отсортированные части сливаются в одну с использованием функции `merge`.
    - В функции `merge` два массива сливаются, сравнивая текущие элементы. Оставшиеся элементы добавляются в конец результирующего массива.
5. **Пример работы**:
    - Исходный массив выводится до сортировки.
    - После вызова `mergeSort`, массив выводится в отсортированном порядке.

**Временная сложность**: O(n log n) во всех случаях.  
**Пространственная сложность**: O(n), так как требуется дополнительная память для хранения объединенных массивов.


#### Сортировка кучей (Heap Sort)

**Принцип работы**: Строится двоичная куча, затем из неё поочередно извлекаются элементы, и в итоге получается отсортированный массив.

### Шаги:

1. Строим кучу из массива.
2. Извлекаем элементы из кучи поочередно и перестраиваем кучу после каждого извлечения.
   
**Код на C++:**

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Функция для преобразования поддерева в кучу
void heapify(vector<int>& numbers, int n, int i) {
    int largest = i;          // Инициализируем наибольший элемент как корень (индекс текущего узла)
    int left = 2 * i + 1;     // Левый потомок узла (формула для вычисления индекса)
    int right = 2 * i + 2;    // Правый потомок узла (формула для вычисления индекса)

    // Если левый потомок существует и больше корня
    if (left < n && numbers[left] > numbers[largest]) {
        largest = left; // Обновляем индекс наибольшего элемента
    }

    // Если правый потомок существует и больше текущего наибольшего элемента
    if (right < n && numbers[right] > numbers[largest]) {
        largest = right; // Обновляем индекс наибольшего элемента
    }

    // Если наибольший элемент не является корнем
    if (largest != i) {
        swap(numbers[i], numbers[largest]); // Меняем местами корень и наибольший элемент

        // Рекурсивно преобразуем затронутое поддерево в кучу
        heapify(numbers, n, largest); // Восстанавливаем свойства кучи для поддерева
    }
}

// Основная функция для выполнения пирамидальной сортировки
void heapSort(vector<int>& numbers) {
    int n = numbers.size(); // Определяем размер массива

    // Построение начальной кучи (перегруппировка массива)
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(numbers, n, i); // Преобразуем каждое поддерево в кучу, начиная с последнего внутреннего узла
    }

    // Один за другим извлекаем элементы из кучи
    for (int i = n - 1; i >= 0; i--) {
        swap(numbers[0], numbers[i]); // Перемещаем текущий корень (наибольший элемент) в конец массива

        heapify(numbers, i, 0); // Восстанавливаем свойства кучи для оставшейся части массива
    }
}

int main() {
    vector<int> numbers = {12, 11, 13, 5, 6, 7}; // Исходный массив, который нужно отсортировать

    cout << "Исходный массив: "; // Выводим сообщение перед печатью массива
    for (int num : numbers) { // Перебираем элементы массива
        cout << num << " "; // Печатаем каждый элемент массива
    }
    cout << endl; // Перевод строки для форматирования вывода

    // Выполняем пирамидальную сортировку
    heapSort(numbers);

    cout << "Отсортированный массив: "; // Выводим сообщение перед печатью отсортированного массива
    for (int num : numbers) { // Перебираем элементы отсортированного массива
        cout << num << " "; // Печатаем каждый элемент массива
    }
    cout << endl; // Перевод строки для завершения вывода

    return 0; // Завершаем выполнение программы
}


```

### Объяснение:

1. **Функция `heapify`**:
    - Преобразует массив в двоичную кучу.
    - Сравнивает родительский элемент с потомками (левым и правым).
    - Если потомок больше родителя, они меняются местами.
    - Выполняется рекурсивно для поддержания структуры кучи.
2. **Построение кучи**:
    - В первой фазе сортировки массив преобразуется в кучу, начиная с последнего внутреннего узла.
3. **Извлечение элементов из кучи**:
    - Максимальный элемент (корень) перемещается в конец массива.
    - Размер кучи уменьшается, и структура кучи восстанавливается с помощью `heapify`.


**Временная сложность**: O(n log n) в худшем, среднем и лучшем случаях.  
**Пространственная сложность**: O(1).

Преимущество: Очень быстрая сортировка, подходит для больших данных.  
Недостаток: Не стабилен (порядок равных элементов может измениться).