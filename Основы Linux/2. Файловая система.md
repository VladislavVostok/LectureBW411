
Основным назначением файловой системы является упорядочение хранимых ресур­ сов системы. Однако программистам не хотелось каждый раз заново изобретать колесо при управлении объектами других типов. Очень часто оказывалось удобным представ­ лять такие объекты в виде эл ементов файловой системы. Подобный унифицированный подход имеет как преимущества (единый программный интерфейс , легкий доступ из интерпретатора команд) , так и недостатки (реализация файловых систем по методу док­ тора Франкенштейна) ,  но независимо от того , нравится он вам или нет,  именно такой подход применяется в системе UNIX (а значит, и в системе Linux). 

Файловую систему можно представить состоящей из четырех основных компонентов: 
•      пространство имен - методы именования объектов и организации их в виде еди­ной иерархии;
•      АРР - набор системных вызовов для перемещения между объектами и управле­ния ими; 
•      модель безопасности - схема защиты , сокрытия и совместного использования объектов; 
•      реализация - программный код, который связывает логические модели с дисковой подсистемой. 

Усложняющим фактором является то , что ядро поддерживает несколь­ ко типов дисковых файловых систем. Доминирующими стандартами в  данный момент являются системы ext4, XFS и  UFS, а также ZFS и  Btrfs компании Oracle. Однако су­ ществует и множество других файловых систем, таких как Vx FS компании Veritas и JFS компании IВМ. 

Есть много реализаций файловых систем  с  другой семантикой,  таких как FAT и NTFS (используются в системе Microsoft Windows)

## 2.1. ИМЕНА ПУТЕЙ 
Файловая система - это единая иерархическая структура, которая начинается с ка­талога **/** и разветвляется, охватывая произвольное число подкаталогов. Каталог само­го верхнего уровня называется корневым . Эта моноиерархическая система отличается от используемой в системе Windows, где применяется понятие пространства имен, осно­ванное на принципе деления диска на разделы.
В графических пользовательских интерфейсах каталоги часто называются папками, даже в системах Linux. Папки и каталоги - одно и то же. Папка - это термин систе м Windows и macOS. Те м не менее стоит отметить, что слово "папка" часто вызывает раз­ дражение у некоторых эксперто в. Не используйте его в техничес ких контекстах, если не готовы ловить на себе иронические взгляды. 
Цепочка имен каталогов, через которые необходимо пройти для доступа к заданному файлу,  вместе с  именем этого файла образуют путь к файлу.  Путь может быть абсолютным (например, **/tmp/foo**) или относительным (например, **book4/filesystem**) . Последние интерпретируются начиная с текущего каталога. Возможно, многие считают, что текущий каталог задается интерпретатором команд. На самом деле текущий каталог есть у каждого процесса. 
Термины **имя файла** и **путь** в той или иной степени являются взаимозаменяемыми. Соответственно, имена файлов и пути бывают абсолютными и относительными. 
Файловое дерево может иметь произвольную глубину, однако каждый компонент имени файла должен состоять не более чем из 255 символов. Существует также огра­ничение на длину пути, который вы можете передавать ядру в качестве аргумента системного вызова (4095 байт в Linux и 1024 байт в BSD). Для того чтобы получить доступ к файлу, полное имя которого превышает эти ограничения, необходимо с помощью ко­манды cd перейти в промежуточный каталог, а затем воспользоваться относительным путем к файлу. 


## 2.2. СТРУКТУРА ФАЙЛОВОГО ДЕРЕВА 
Файловые системы в системе UN IX никогда не были хорошо организованы. В ней одновременно используется много разных, несовместимых соглашений об именовании файлов. Во многих случаях файлы группируются по выполняемым функциям, независимо от того, как часто они изменяются. Эrо затрудняет обновление операционной системы. 

Например, каталог **/etc** содержит ряд файлов, которые никогда не меняются , а также локальные файлы. Как определить, какие файлы нельзя трогать при обновлении системы? Эrо нужно просто знать... или верить, что программа инсталляции примет правильные решения. 

Системные администраторы, стремящиеся к логической стройности , иногда подда­ются соблазну улучшить структуру файлового дерева, принятую по умолчанию. К со­жалению, файловое дерево имеет много скрытых зависимостей, поэтому попытки изме­нить его структуру создает новые проблемы. Просто предоставьте операционной системе самой решать, где разместить системные пакеты. Если же вам предлагают изменить ме­стоположение пакетов, всегда соглашайтесь на вариант, принятый по умолчанию, иначе у вас возникнут неприятности. 

Корневая файловая система содержит корневой каталог и минимальный набор фай­лов и  подкаталогов. Файл ядра находится в недрах корневой файловой системы, но не имеет стандартного имени или точного местоположения; в системе BSD это даже не один файл , а, скорее, набор компонентов. 

Частью корневой файловой системы являются также каталог **/etc** для критических системных файлов и файлов конфигурации, каталоги **/sbin** и **/bin** -   для важных утилит и иногда каталог **/tmp** -   для временных файлов. В прошлом каталог **/dev** представ­лял собой реальный каталог, включенный в корневую файловую систему, но сейчас он является виртуальной файловой системой, которая монтируется отдельно.

Одни системы хранят совместно используемые библиотечные файлы и прочие важ­ные программы (например, препроцессор языка С) в каталоге **/lib** или **/libб4**. Другие переместили эти элементы в каталог **/usr/lib**, оставив для каталога **/lib** роль симво­лической ссылки. 

Огромное значение имеют также каталоги **/usr** и **/var**. В первом хранится большинство стандартных программ и другие полезные компоненты, в частности интерактивная документация и библиотеки. Совсем не обязательно, чтобы каталог **/usr** был отдельной файловой системой, однако для удобства администрирования его, как правило, монти­руют именно так. Для того чтобы система могла загружаться в многопользовательском режиме, необходимы оба каталога -    **/usr** и **/var**. 

В прошлом было принято разбивать системный диск на разделы и размещать в них отдельные части файлового дерева (в основном в каталогах **/usr, /var и  /tmp**). Эта практика не исчезла полностью и в настоящее время,  но основной тенденцией стало использование одной большой корневой файловой системы. Большие жесткие диски и возрастающая сложность реализаций файловых систем снизили ценность разбиения дисков на разделы. 

Чаще всего разбиение диска используют для того, чтобы одна часть файлового дерева не занимала все доступное пространство и не вызывала сбой системы. Соответственно, чаще всего разбиению подвергаются каталог **/var** (содержащий файлы журнала, разме­ры которых со временем растут и могут вызвать проблемы), **/tmp** и рабочие каталоги пользователей. 

Специальные файловые системы могут хранить большие объемы инфор­мации, например библиотеки исходных кодов и базы данных. 

[[8619d71312c8595f21148d209f4812de_MD5.jpeg|Open: Pasted image 20250319144714.png]]
![[8619d71312c8595f21148d209f4812de_MD5.jpeg]]
[[b7d736377695c2c8d7aa607d8f47a4fe_MD5.jpeg|Open: Pasted image 20250319144732.png]]
![[b7d736377695c2c8d7aa607d8f47a4fe_MD5.jpeg]]

## Команды Linux для управления файлами

1. `ls` – отображает список файлов и каталогов в текущей директории.
2. `cd` – изменяет текущую директорию.
3. `pwd` – выводит полный путь текущей директории.
4. `mkdir` – создает новый каталог.
5. `rm` – удаляет файлы или каталоги.
6. `cp` – копирует файлы и каталоги.
7. `mv` – перемещает или переименовывает файлы и каталоги.
8. `touch` – создает новый файл или обновляет время доступа и модификации существующего файла.
9. `cat` – выводит содержимое файла.
10. `less` – позволяет просматривать содержимое файла постранично.
11. `head` – выводит первые строки файла.
12. `tail` – выводит последние строки файла.
13. `grep` – ищет заданный текст в файлах или выводе команд.
14. `find` – находит файлы и каталоги на основе различных критериев.
15. `chmod` – изменяет права доступа к файлам и каталогам.
16. `chown` – изменяет владельца файлов и каталогов.
17. `chgrp` – изменяет группу файлов и каталогов.
18. `tar` – создает или распаковывает архивы.
19. `zip` – создает ZIP-архивы.
20. `unzip` – извлекает файлы из ZIP-архивов.

## Команды Linux для управления пользователями

1. `adduser` – создает нового пользователя.
2. `usermod` – изменяет параметры существующего пользователя.
3. `deluser` – удаляет пользователя.
4. `passwd` – изменяет пароль пользователя.
5. `su` – переключается на другого пользователя или становится суперпользователем.
6. `sudo` – выполняет команду с привилегиями суперпользователя.
7. `finger` – отображает информацию о пользователе.
8. `who` – отображает информацию о вошедших пользователях.
9. `id` – отображает информацию о текущем пользователе или указанном пользователе.
10. `groups` – отображает группы, к которым принадлежит пользователь.
11. `useradd` – создает нового пользователя (альтернатива для `adduser`).
12. `userdel` – удаляет пользователя (альтернатива для `deluser`).
13. `usermod` – изменяет параметры существующего пользователя (альтернатива для usermod).
14. `passwd` – изменяет пароль пользователя (альтернатива для passwd).
15. `last` – отображает историю входа пользователей.
16. `w` – отображает текущих пользователей и их активность.
17. `logout` – выходит из текущей сессии пользователя.

## Команды Linux для управления приложениями

1. `apt-get install` – устанавливает новое приложение или пакет.
2. `apt-get remove` – удаляет установленное приложение или пакет.
3. `apt-get update` – обновляет список доступных обновлений пакетов.
4. `apt-get upgrade` – обновляет установленные пакеты до последних версий.
5. `apt-cache search` – ищет пакеты по ключевому слову.
6. `dpkg -i` – устанавливает .deb пакет.
7. `dpkg -r` – удаляет .deb пакет.
8. `dpkg -l` – отображает список установленных пакетов.
9. `snap install` – устанавливает приложение из snap-пакета.
10. `snap remove` – удаляет установленное snap-приложение.
11. `snap list` – отображает список установленных snap-приложений.
12. `systemctl start` – запускает системную службу.
13. `systemctl stop` – останавливает системную службу.
14. `systemctl restart` – перезапускает системную службу.
15. `systemctl enable` – включает автозапуск системной службы при загрузке системы.
16. `systemctl disable` – отключает автозапуск системной службы при загрузке системы.
17. `service <service> start` – запускает службу.
18. `service <service> stop` – останавливает службу.
19. `service <service> restart` – перезапускает службу.
20. `service <service> status` – отображает статус службы.

## Команды Linux для управления системой

1. `shutdown` – позволяет выключить или перезагрузить систему. Например, `shutdown -h now` выключает систему немедленно.
2. `reboot` – перезагружает систему. Просто запустите `reboot` в терминале.
3. `halt` – выключает систему. Просто запустите `halt` в терминале.
4. `poweroff` – выключает систему. Просто запустите `poweroff` в терминале.
5. `systemctl` – команда для управления системными сервисами. Например, `systemctl start apache2` запускает службу Apache.
6. `service` – альтернативный способ управления системными службами. Например, `service nginx restart` перезапускает службу Nginx.
7. `ifconfig` – отображает и настраивает сетевые интерфейсы системы, включая IP-адреса, маски и шлюзы.
8. `ip` – альтернативный способ управления сетевыми интерфейсами и конфигурацией сети.
9. `netstat` – отображает сетевые соединения, открытые порты и другую связанную информацию.
10. `ping` – отправляет ICMP-пакеты на указанный IP-адрес для проверки доступности хоста в сети.
11. `traceroute` – отображает путь, по которому проходят пакеты до указанного IP-адреса в сети.
12. `ssh` – устанавливает безопасное соединение с удаленным сервером по протоколу SSH.
13. `scp` – копирует файлы между удаленным и локальным серверами по протоколу SSH.
14. `rsync` – выполняет синхронизацию и копирование файлов между удаленными и локальными серверами.
15. `crontab` – позволяет управлять cron-задачами, которые выполняются автоматически по заданному расписанию.
16. `at` – позволяет запускать команды или скрипты в определенное время в будущем.
17. `shutdown` – планирует выключение или перезагрузку системы по расписанию.
18. `nohup` – запускает команду с игнорированием сигналов завершения процесса. Это полезно для выполнения задач в фоновом режиме.
19. `history` – отображает историю команд, введенных пользователем в терминале.

## Команды Linux для управления процессами

1. `top` – отображает список процессов и их характеристики, такие как использование CPU и памяти.
2. `ps` – выводит список текущих запущенных процессов с их идентификаторами (PID).
3. `kill` – отправляет сигнал процессу для его завершения. Например, `kill PID` завершит процесс с указанным идентификатором.
4. `pkill` – отправляет сигнал процессам по их имени или другим атрибутам. Например, `pkill firefox` завершит все процессы Firefox.
5. `htop` – интерактивное утилита мониторинга процессов, которая позволяет видеть дополнительную информацию и управлять процессами.
6. `free` – отображает общую, использованную и свободную память системы, включая физическую и подкачку.
7. `vmstat` – предоставляет информацию о использовании памяти, процессоре, вводе-выводе, планировании и других системных ресурсах.
8. `killall` – завершает все процессы с указанным именем. Например, `killall firefox` завершит все процессы Firefox.
9. `renice` – изменяет приоритет процесса в реальном времени. Например, `renice -n -5 -p PID` увеличит приоритет процесса с указанным идентификатором.
10. `nice` – запускает процесс с более низким приоритетом. Например, `nice -n 10 command` запустит команду с очень низким приоритетом.
11. `pgrep` – выводит идентификаторы процессов, соответствующие указанной строке. Например, `pgrep firefox` выведет идентификаторы процессов Firefox.
12. `strace` – отслеживает системные вызовы и сигналы, связываемые с процессом. Можно использовать для отладки или анализа процессов.
13. `lsof` – выводит открытые файлы и сетевые соединения для всех процессов на системе.
14. `sar` – собирает информацию о использовании ресурсов системы, таких как процессор, память, сеть и диски, и сохраняет ее для последующего анализа.
15. `uptime` – выводит информацию о времени работы системы, средней загрузке и количестве активных пользователей.
16. `time` – запускает команду и отображает время, затраченное на ее выполнение, включая CPU-время и время ввода-вывода.

## Команды Linux для управления памятью

1. `smem` – отображает детальную информацию об использовании памяти процессами, группами процессов и системой в целом.
2. `sync` – записывает все буферы операционной системы на диск, чтобы обеспечить сохранность данных перед завершением работы.
3. `swapoff` – отключает файл подкачки, что позволяет освободить диск, но может увеличить использование оперативной памяти.
4. `swapon` – включает файл подкачки, добавляя дополнительную виртуальную память для использования системой.
5. `sysctl` – позволяет просматривать и изменять настройки ядра, включая параметры, связанные с памятью.
6. `ulimit` – устанавливает ограничения на использование ресурсов, включая память, для отдельного пользователя или процесса.
7. `pmap` – выводит карту памяти процесса, позволяя увидеть как процесс использует физическую и виртуальную память.
8. `slabtop` – отображает информацию о кэшах ядра, которые используют физическую память системы.
9. `ulimit` – устанавливает ограничения на использование ресурсов, включая память, для отдельного пользователя или процесса.
10. `numactl` – управляет доступом процессов к памяти и процессорам, особенно в многоядерных системах.
11. `sysrq` – позволяет отправлять системным вызовом определенные команды ядру Linux, в том числе сброс памяти (Memory Management).
12. `mdb` – интерактивный отладчик для системы Solaris, который может использоваться для анализа памяти.