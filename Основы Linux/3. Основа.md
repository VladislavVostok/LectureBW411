
### **Перенаправление ввода/вывода** 

С помощью *перенаправления ввода/вывода* мы можем перенаправить вывод одной 
программы в файл или на стандартный ввод другой программы. Например, у вас не 
получается настроить сеть, и вы хотите перенаправить вывод команды ifconfig 
в файл, а затем разместить этот файл на форуме, где вам помогут разобраться 
с проблемой. А можно командой ps -ах перенаправить список всех процессов команде grep, которая найдет в списке интересующий вас процесс. 

**Рассмотрим следующую команду:** 

```bash
echo "sorne  text" > file.txt 
```

Символ > означает, что вывод команды, находящейся слева от этого символа, будет 
записан в файл, находящийся справа от символа, при этом файл будет перезаписан. Чуть ранее мы говорили о перенаправлении вывода программы ifconfig в файл. 

**Команда будет выглядеть так:** 

```bash
ifconfig > ifconfig.txt 
```

Если вместо **>** указано **>>**, то исходный файл не будет перезаписан, а вывод коман­ды добавится в конец файла:

```bash
echo "some  text" > file.txt 
echo  "more  text"  >>   file.txt
``` 

```bash
cat file.txt 
```

```txt
some text 
mоrе text 
```

Кроме символов **>** и **>>** для перенаправления **ввода/вывода** часто употребляется 
вертикальная черта **|** . Предположим, что мы хотим вывести содержимое файла 
**big_text**: 

```sh
cat big_text 
```

Но в файле big_text много строк, они быстро проскочат по экрану, и мы ничего не успеем прочитать. Следовательно, целесообразно отправить вывод команды **саt** какой-то программе, которая будет выводить файл на экран постранично, напри­мер: 

```sh
cat big_text | more 
```

Есть и другие примеры более убедительные и есть утилита less:

```sh
less big_text
```

Есть интересный пример. Допустим, мы хотим удалить файл file.txt без запроса:

```sh
echo y | rm file.txt
```

Команда rm запросит подтверждения на удаление, соответственно нам нужно нажать клавишу **Y**, но за нас это сделает команда echo.

Следующий пример. Пусть имеется большой файл, и нам нужно нийти в нём все строки, содержащие подстроку 55555-55555. Чтобы не делать это вручную, можно использовать команду:

```sh
cat file.txt | grep "55555-55555"
```


### Команды для работы с файлами и каталогами

#### Работа с файлами

[[05e460acc6999c6eeed3111a92d38d31_MD5.jpeg|Open: Pasted image 20250402130449.png]]
![[05e460acc6999c6eeed3111a92d38d31_MD5.jpeg]]

```sh
touch file.txt
```

```sh
echo  "some  text" >  file.txt 
```

```sh
cat file.txt 
```

```sh
cp file.txt file-copy.txt 
```

```sh
cat file-copy.txt 
```

```sh
rm file.txt 
```

```sh
cat file.txt 
```

```sh
mv file-copy.txt file.txt 
```

```sh
cat file.txt
```


- Первая команда (**touch**) создает в текущем каталоге файл file. txt. 
- Вторая команда (**echo**) записывает строку some  text в этот же файл. Обратите внимание на сим­вол **>** - это символ перенаправления ввода/вывода, о котором мы поговорим чуть позже. 
- Третья команда (cat) выводит содержимое файла - в файле записанная нами стро­ка some  text. 
- Четвертая команда (ер) копирует файл file. txt в файл с именем file-copy. txt. После этого мы опять используем команду cat, чтобы вывести содержи­мое файла file-copy. txt, - надо же убедиться, что файл действительно скопиро­вался.
- Шестая команда (пn) удаляет файл file. txt. При удалении система спрашивает, хотите ли вы удалить файл. Если хотите удалить, то нужно нажать клавишу У, а если нет, то клавишу N. Точно ли файл удален? Убедимся в этом: введите команду cat file. txt. Система нам сообщает, что такого файла нет. 
- Восьмая команда (mv) переименовывает файл file-eopy. txt в файл file. txt. По­следняя команда (cat) выводит новый файл file.txt. 

Вместо имени файла иногда очень удобно указать маску имени файла. Например, у нас есть много временных файлов, имена которых заканчиваются фрагментом **tmp**. Дпя их удаления нужно воспользоваться командой: 

```
rm  *.tmp
``` 

Можно удалить все файлы в каталоге:

```
rm *
```

Также можно использовать ? знак вопроса, который в отличие от `*`, которая заменяет последовательность символов произвольной длинны, то ? заменяет всего одним символом. Пример, удалить все файлы, имена которых состоят из трёх букв и начинаются на s:

```sh
rm s??
```

#### Работа с каталогами

[[05aea1a36c9abac060df94410b67cd2f_MD5.jpeg|Open: Pasted image 20250402131733.png]]
![[05aea1a36c9abac060df94410b67cd2f_MD5.jpeg]]

Команда выводит полный путь до текущей директории (каталога):
```sh
pwd 
```

Команда выводит содержимое текущей директории:
```sh
dir
```

Команда выводит содержимое директории по пути:
```sh
dir <path>
```




При указании каталога можно использовать следующие символы:
`.` - означает текущий каталог. Если ввести команду

```sh
cat ./file
```

она выведет содержимое файла, который лежит в текущем каталоге.

`..` - родительский каталог. Например, команда 

```bash
cd ..
```

переведёт вас на один уровень вверх по дереву файловой системы

`~`  -  домашний каталог пользователя.


```sh
mkdir directory
```

```sh
cd directory
```

```sh
touch file1.txt
```

```sh
touch file2.txt
```

```sh
ls
```

```sh
cd ..
```

```sh
ls directory
```

```sh
rm directory
```

```sh
rmdir directory
```

```sh
rm -r directory
```

```
ВАЖНО!!! Прямой слэш!

Обратите внимание, что в Linux, в отличие от Windows, для разделения элементов пути служит прямой слэш (/), а не обратный (`\`).
```

Кроме обозначений `..` и `.`в Linux часто используется символ "тильда" (`~`) - так обозначается **домашний каталог**. Предположим, что наш домашний каталог /home/shalom и нам нужен файл file.txt, который лежит в директории dir. Путь будет выглядеть так: `/home/shalom/dir/file.txt`, но мы можем этот путь сократить используя такой путь: `~/dir/file.txt`


### Использование ссылок. Команда ln.

#### Жесткие и мягкие (символьные) ссылки

Файлы и каталоги физически хранятся на носителе в виде набора блоков. Информация о файле (владелец, права доступа, размер файла, время последнего обращения, признак каталога и т. д. хранится в inode - индексном дескрипторе. 

Номер inode также называют порядковым номером файла. Этот номер является уникальным в пределах отдельной файловой системы. Запись каталога содержит имя файла или каталога), a также указатель на дескриптор inode, в котором хранится информация об этом файле каталоге).

Ссылки это дополнительные записи каталога, позволяющие обращаться к файлам или каталогам по нескольким именам. Жесткая ссылка - это запись каталога, указывающая на дескриптор inode, a мягкая (или символическая) ссылка это запись каталога, указывающая на имя объекта с другим inode. 

Механизмы хранения дополнительных имен (ссылок) зависят от типа файловой системы и от длины имени. 

Жесткие ссылки можно создать только для файлов, для каталогов их создать невозможно. Исключение составляют лишь специальные записи каталогов, указывающие на сам каталог и на ее родительский каталог т.е.  `.` и `..` являются жесткими ссылками При попытке создать ссылку для каталога вы увидите следующее сообщение об ошибке: 

```txt
In: link hard link not allowed for directory 
In: link не допускается создавать жесткие ссылки на каталоги 
```


Жесткие ссылки можно использовать только в пределах одной файловой системы, поскольку они являются указателями на дескрипторы inode, которые как уже отмечалось, являются уникальными только в пределах отдельной файловой системы. 

Файл удаляется только тогда, когда удаляется последняя ссылка на его inode и счетчик ссылок сбрасывается до `0`. Об удалении ссылок мы поговорим позже, т. к. этот вопрос заслуживает отдельного рассмотрения.

**Мягкая**, или **символическая**, ссылка (symlink) указывает на имя другого файла или каталога, а не на его inode. В этом и есть отличие мягких ссылок от жестких Мягкие ссылки можно создавать на объекты разных файловых систем, a также на каталоги. Удаление мягкой ссылки не приводит к удалению файла или каталога, на которую она указывает, a удаление целевого объекта не приводит к автоматическому удалению мягких ссылок. Другими словами, если y вас есть файл file.txt и вы создали на него символическую ссылку symlink.txt, то в случае удаления файла file.txt ссылка окажется «битой» она не будет ни на что указывать. 

#### Создание ссылок 

Для создания ссылок служит команда `In`: 

```sh
ln file.txt link1
``` 

```sh
ln -s file.txt link2
``` 

- Первая команда создает жесткую ссылку link1, ссылающуюся на текстовый файл file.txt. 
- Вторая команда создает символическую ссылку link2, которая ссылается на этот же текстовый файл file.txt 

Модифицируя ссылку (все равно какую: link1 или link2), вы автоматически модифицируете исходный файл file.txt 

#### Определение ссылок 

Мы только что научились создавать ссылки. Теперь давайте посмотрим, как различить где файл, a где ссылка. Представим, что мы создали файл и две ссылки на него: 

```sh
echo "Hello" > file
```

```sh
ln -s file symlink
```

```sh
ln file hardlink
``` 


Если ввести команду `ls`, то символическая ссылка будет выделена цветом. Каким именно зависит от вашего дистрибутива. Если в вашем дистрибутиве символические ссылки не выделяются, попробуйте указать опцию `--color=auto`: 

```sh
ls --color=auto
``` 

А вот жесткие ссылки никак не выделяются, и визуально нельзя понять: перед нами файл или ссылка по крайней мере. Однако есть дистрибутивы где жесткие ссылки выделяются каким-либо цветом - например, темно-синим. 

Рассмотрим вывод команды `ls -l`:

```sh
ls -l
```


Также найти все символические ссылки можно с помощью команды find: 

```sh
find . -type l
```

Найти с помощью этой команды все символические ссылки на файл "file" можно 
так: 

```sh
find . -lname "file" 
```

С жесткими ссылками все не так просто. Первая колонка вывода команды `ls -l` -
это права доступа. Вторая колонка - счетчик жестких ссылок.


Посмотрим на вывод команды `ls  -i`, которая показывает индексные дескрипторы 
файлов:

```sh
ls -i 
```

Как можно видеть, здесь есть два одинаковых дескриптора и два имени для этого дескриптора. 


#### Удаление файлов и жесткие ссылки


В предыдущем разделе приводился вывод команды `ls` с опцией `-i`. Посмотрите на вывод команды `ls  -l`  -  вторая колонка показывает на inode. По сути, в этом контексте нет особой разницы количество жестких между ссылкой и файлом. Вы можете удалить файл file: 

```sh
rm file
```

```sh
ls -l
``` 

И вы увидите, что счетчик ссылок оказался уменьшен на единицу. Но ваши данные 
останутся в файле hardlink, и вы сможете их прочитать. Почему же файл file был удален, если на него указывала жесткая ссылка hardlink? Потому, что жесткая  ссылка указывает не на имя файла, а на inode! А ведь индексный дескриптор остался, и он не будет удален, пока счетчик жестких ссылок больше `0`! 

Именно поэтому, если вы хотите защитить файл от удаления путем создания на него жесткой ссылки, это неправильный вариант. Для защиты файла от случайного удаления используйте команду `chattr +i`:

```sh
touch  f 
```

```sh
sudo chattr +i  f 
```

```sh
rm f 
```


Удалить файл можно, только сняв флаг i: 
```sh
chattr -i f 
```

Кстати, после удаления файла file, на который указывала символическая ссылка symlink, последняя превращается в «битую» ссылку - в отмечается красным цветом на черном фоне. Таким образом, превращается в «битую» по следующим причинам: 
- удаление целевого файла; 
- переименование целевого файла; 
- переименование элементов пути к целевому файлу. Например на файл /home/den/links/file, а потом каталог links был переименован в test.

Возвращаемся к жестким ссылкам - найти все жесткие ссылки на файл можно командой find с опцией -samefile: 

```sh
find . -samefile file 
```

#### Разница между копированием и созданием жесткой ссылки 

Учитывая, что жесткая ссылка - это практически то же что и файл, возни­кает вопрос: когда лучше копировать файл, а когда создавать? 

Все зависит от поставленных задач. Ведь жесткая ссылка ссылается на тот же inode, что и файл, следовательно, при изменении файла (или ссылки) изменяется и содержимое файла. Если же вы создаете копию файла, другой inode и, следовательно, изменение копии никак не отразится на оригинале  и наоборот.


#### Права доступа и атрибуты файла. Команды chown, chmod и chattr 
#### Права доступа к файлам и каталогам 

Для каждого каталога и файла вы можете задать права доступа. Точнее, права доступа автоматически задаются при создании каталога/файла, a вы при необходимости можете их изменить. Какая может быть необходимость? Например, вам нужно чтобы к вашему файлу-отчету смогли получить доступ пользователи члены вашей группы. Или вы создали обычный текстовый файл, содержащий инструкции командного интерпретатора. Чтобы этот файл стал сценарием, вам нужно установить право на выполнение для этого файла. 

Существуют три права доступа чтение (r), запись (w), выполнение (x). Для каталога право на выполнение означает право на просмотр содержимого каталога.

Вы можете установить разные права доступа для владельца (т. e. для себя), для группы владельца (т. e. для всех пользователей входящих в одну с владельцем) и для прочих пользователей. Пользователь root может получить доступ к любому файлу или каталогу вне зависимости от прав, которые вы установили.


Чтобы просмотреть текущие права доступа, введите команду: 

```ls
ls -l <имя файла/каталога> 
```

Например, 

```
ls -l video.txt 
```

В этой строке фрагмент `-r--r-----` описывает права доступа: 
- первый символ это признак каталога. Сейчас перед нами файл Если бы перед нами был каталог то первый символ был бы символом а (от directory); 
- последующие три символа (г--) определяют права доступа владельца файла или каталога Первый символ это чтение, второй запись, третий выполнение Как можно видеть, владельцу разрешено только чтение этого файла, запись и выполнение запрещены, поскольку в правах доступа режимы w и x не определены; 
- следующие три символа (r--) задают права доступа для членов группы владельца. Права такие же, как и y владельца: можно читать файл, но нельзя изменять или запускать;
- последние три символа (---) задают права доступа для прочих пользователей. Прочие пользователи не имеют права ни читать, ни изменять, ни выполнять файл. При попытке получить доступ к файлу они увидят сообщение Access denied.

```
ПОЛНЫЙ ВЫВОД КОМАНДЫ LS 
	Как можно видеть, после символов прав доступа команда `ls` выводит имя владельца файла, имя группы владельца, размер файла, дату и время создания, а также имя файла.
```

Права доступа задаются командой chmod. Существуют два способа указания прав  
доступа: символьный (когда указываются символы, задающие право доступа r  
w, х ) и абсолютный.

Так уж заведено, что в мире UNIX-подобных систем чаще пользуются абсолютным  
методом. Разберемся, в чем он заключается, и рассмотрим следующий набор прав  
доступа: 

`rw-r-----` 

Этот набор предоставляет владельцу право чтения и модификации файла (rw-),  
запускать файл владелец не может. Члены группы владельца могут только проcматривать файл (r--), a все остальные пользователи не имеют вообще никакого доступа к файлу.

Возьмем отдельный набор прав, например, для владельца: `rw-`.  
Чтение разрешено мысленно записываем `1` запись разрешена запоминаем еще 1, a вот выполнение запрещено, поэтому запоминаем `0`. Получается число `110`. Если перевести число 110 из двоичной системы в восьмеричную получится число 6. 


[[95c266b384681539b9b30272c8975935_MD5.jpeg|Open: Pasted image 20250402145155.png]]
![[95c266b384681539b9b30272c8975935_MD5.jpeg]]

Аналогично произведем разбор прав для членов группы владельца. Получится двоичное 100, т. е. восьмеричное 4 третьим набором (---) все вообще просто это `000`,  т. e. `0`  

Записываем полученные числа в восьмеричной системе в порядке: владелец  - 
группа - остальные. Получится число `640` это и есть права доступа. Для того  
чтобы установить эти права доступа, выполните команду:  

```sh
chmod 640 <имя файла>  
```

**Наиболее популярные права доступа:**  
- 644 - владельцу можно читать и изменять файл, остальным пользователям  
только читать;
- 666 - читать и изменять файл можно всем пользователям;
- 777 - всем можно читать, изменять и выполнять файл. 

```
ПРАВО ВЫПОЛНЕНИЯ ДЛЯ КАТАЛОГА 
это право просмотра оглавления ка­ Напомню, что для каталога право выполнения -
талога. 
```


Иногда символьный метод оказывается проще. Например, чтобы файл script сделать 
исполнимым, можно отдать команду: 

```sh
chmod +х script 
```

Для того чтобы снять право выполнения, указывается параметр -х: 

```
chmod -х script 
```

Подробнее о символьном методе вы сможете прочитать в руководстве по команде 
chrnod (выполнив команду man  chrnod). 