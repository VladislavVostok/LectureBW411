
### **Перенаправление ввода/вывода** 

С помощью *перенаправления ввода/вывода* мы можем перенаправить вывод одной 
программы в файл или на стандартный ввод другой программы. Например, у вас не 
получается настроить сеть, и вы хотите перенаправить вывод команды ifconfig 
в файл, а затем разместить этот файл на форуме, где вам помогут разобраться 
с проблемой. А можно командой ps -ах перенаправить список всех процессов команде grep, которая найдет в списке интересующий вас процесс. 

**Рассмотрим следующую команду:** 

```bash
echo "sorne  text" > file.txt 
```

Символ > означает, что вывод команды, находящейся слева от этого символа, будет 
записан в файл, находящийся справа от символа, при этом файл будет перезаписан. Чуть ранее мы говорили о перенаправлении вывода программы ifconfig в файл. 

**Команда будет выглядеть так:** 

```bash
ifconfig > ifconfig.txt 
```

Если вместо **>** указано **>>**, то исходный файл не будет перезаписан, а вывод коман­ды добавится в конец файла:

```bash
echo "some  text" > file.txt 
echo  "more  text"  >>   file.txt
``` 

```bash
cat file.txt 
```

```txt
some text 
mоrе text 
```

Кроме символов **>** и **>>** для перенаправления **ввода/вывода** часто употребляется 
вертикальная черта **|** . Предположим, что мы хотим вывести содержимое файла 
**big_text**: 

```sh
cat big_text 
```

Но в файле big_text много строк, они быстро проскочат по экрану, и мы ничего не успеем прочитать. Следовательно, целесообразно отправить вывод команды **саt** какой-то программе, которая будет выводить файл на экран постранично, напри­мер: 

```sh
cat big_text | more 
```

Есть и другие примеры более убедительные и есть утилита less:

```sh
less big_text
```

Есть интересный пример. Допустим, мы хотим удалить файл file.txt без запроса:

```sh
echo y | rm file.txt
```

Команда rm запросит подтверждения на удаление, соответственно нам нужно нажать клавишу **Y**, но за нас это сделает команда echo.

Следующий пример. Пусть имеется большой файл, и нам нужно нийти в нём все строки, содержащие подстроку 55555-55555. Чтобы не делать это вручную, можно использовать команду:

```sh
cat file.txt | grep "55555-55555"
```


### Команды для работы с файлами и каталогами

#### Работа с файлами

[[05e460acc6999c6eeed3111a92d38d31_MD5.jpeg|Open: Pasted image 20250402130449.png]]
![[05e460acc6999c6eeed3111a92d38d31_MD5.jpeg]]

```sh
touch file.txt
```

```sh
echo  "some  text" >  file.txt 
```

```sh
cat file.txt 
```

```sh
cp file.txt file-copy.txt 
```

```sh
cat file-copy.txt 
```

```sh
rm file.txt 
```

```sh
cat file.txt 
```

```sh
mv file-copy.txt file.txt 
```

```sh
cat file.txt
```


- Первая команда (**touch**) создает в текущем каталоге файл file. txt. 
- Вторая команда (**echo**) записывает строку some  text в этот же файл. Обратите внимание на сим­вол **>** - это символ перенаправления ввода/вывода, о котором мы поговорим чуть позже. 
- Третья команда (cat) выводит содержимое файла - в файле записанная нами стро­ка some  text. 
- Четвертая команда (ер) копирует файл file. txt в файл с именем file-copy. txt. После этого мы опять используем команду cat, чтобы вывести содержи­мое файла file-copy. txt, - надо же убедиться, что файл действительно скопиро­вался.
- Шестая команда (пn) удаляет файл file. txt. При удалении система спрашивает, хотите ли вы удалить файл. Если хотите удалить, то нужно нажать клавишу У, а если нет, то клавишу N. Точно ли файл удален? Убедимся в этом: введите команду cat file. txt. Система нам сообщает, что такого файла нет. 
- Восьмая команда (mv) переименовывает файл file-eopy. txt в файл file. txt. По­следняя команда (cat) выводит новый файл file.txt. 

Вместо имени файла иногда очень удобно указать маску имени файла. Например, у нас есть много временных файлов, имена которых заканчиваются фрагментом **tmp**. Дпя их удаления нужно воспользоваться командой: 

```
rm  *.tmp
``` 

Можно удалить все файлы в каталоге:

```
rm *
```

Также можно использовать ? знак вопроса, который в отличие от `*`, которая заменяет последовательность символов произвольной длинны, то ? заменяет всего одним символом. Пример, удалить все файлы, имена которых состоят из трёх букв и начинаются на s:

```sh
rm s??
```

#### Работа с каталогами

[[05aea1a36c9abac060df94410b67cd2f_MD5.jpeg|Open: Pasted image 20250402131733.png]]
![[05aea1a36c9abac060df94410b67cd2f_MD5.jpeg]]

Команда выводит полный путь до текущей директории (каталога):
```sh
pwd 
```

Команда выводит содержимое текущей директории:
```sh
dir
```

Команда выводит содержимое директории по пути:
```sh
dir <path>
```




При указании каталога можно использовать следующие символы:
`.` - означает текущий каталог. Если ввести команду

```sh
cat ./file
```

она выведет содержимое файла, который лежит в текущем каталоге.

`..` - родительский каталог. Например, команда 

```bash
cd ..
```

переведёт вас на один уровень вверх по дереву файловой системы

`~`  -  домашний каталог пользователя.


```sh
mkdir directory
```

```sh
cd directory
```

```sh
touch file1.txt
```

```sh
touch file2.txt
```

```sh
ls
```

```sh
cd ..
```

```sh
ls directory
```

```sh
rm directory
```

```sh
rmdir directory
```

```sh
rm -r directory
```

```
ВАЖНО!!! Прямой слэш!

Обратите внимание, что в Linux, в отличие от Windows, для разделения элементов пути служит прямой слэш (/), а не обратный (`\`).
```

Кроме обозначений `..` и `.`в Linux часто используется символ "тильда" (`~`) - так обозначается **домашний каталог**. Предположим, что наш домашний каталог /home/shalom и нам нужен файл file.txt, который лежит в директории dir. Путь будет выглядеть так: `/home/shalom/dir/file.txt`, но мы можем этот путь сократить используя такой путь: `~/dir/file.txt`


### Использование ссылок. Команда ln.

#### Жесткие и мягкие (символьные) ссылки

Файлы и каталоги физически хранятся на носителе в виде набора блоков. Информация о файле (владелец, права доступа, размер файла, время последнего обращения, признак каталога и т. д. хранится в inode - индексном дескрипторе. 

Номер inode также называют порядковым номером файла. Этот номер является уникальным в пределах отдельной файловой системы. Запись каталога содержит имя файла или каталога), a также указатель на дескриптор inode, в котором хранится информация об этом файле каталоге).

Ссылки это дополнительные записи каталога, позволяющие обращаться к файлам или каталогам по нескольким именам. Жесткая ссылка - это запись каталога, указывающая на дескриптор inode, a мягкая (или символическая) ссылка это запись каталога, указывающая на имя объекта с другим inode. 

Механизмы хранения дополнительных имен (ссылок) зависят от типа файловой системы и от длины имени. 

Жесткие ссылки можно создать только для файлов, для каталогов их создать невозможно. Исключение составляют лишь специальные записи каталогов, указывающие на сам каталог и на ее родительский каталог т.е.  `.` и `..` являются жесткими ссылками При попытке создать ссылку для каталога вы увидите следующее сообщение об ошибке: 

```txt
In: link hard link not allowed for directory 
In: link не допускается создавать жесткие ссылки на каталоги 
```


Жесткие ссылки можно использовать только в пределах одной файловой системы, поскольку они являются указателями на дескрипторы inode, которые как уже отмечалось, являются уникальными только в пределах отдельной файловой системы. 

Файл удаляется только тогда, когда удаляется последняя ссылка на его inode и счетчик ссылок сбрасывается до `0`. Об удалении ссылок мы поговорим позже, т. к. этот вопрос заслуживает отдельного рассмотрения.

**Мягкая**, или **символическая**, ссылка (symlink) указывает на имя другого файла или каталога, а не на его inode. В этом и есть отличие мягких ссылок от жестких Мягкие ссылки можно создавать на объекты разных файловых систем, a также на каталоги. Удаление мягкой ссылки не приводит к удалению файла или каталога, на которую она указывает, a удаление целевого объекта не приводит к автоматическому удалению мягких ссылок. Другими словами, если y вас есть файл file.txt и вы создали на него символическую ссылку symlink.txt, то в случае удаления файла file.txt ссылка окажется «битой» она не будет ни на что указывать. 

#### Создание ссылок 

Для создания ссылок служит команда `In`: 

```sh
ln file.txt link1
``` 

```sh
ln -s file.txt link2
``` 

- Первая команда создает жесткую ссылку link1, ссылающуюся на текстовый файл file.txt. 
- Вторая команда создает символическую ссылку link2, которая ссылается на этот же текстовый файл file.txt 

Модифицируя ссылку (все равно какую: link1 или link2), вы автоматически модифицируете исходный файл file.txt 

#### Определение ссылок 

Мы только что научились создавать ссылки. Теперь давайте посмотрим, как различить где файл, a где ссылка. Представим, что мы создали файл и две ссылки на него: 

```sh
echo "Hello" > file
```

```sh
ln -s file symlink
```

```sh
ln file hardlink
``` 


Если ввести команду `ls`, то символическая ссылка будет выделена цветом. Каким именно зависит от вашего дистрибутива. Если в вашем дистрибутиве символические ссылки не выделяются, попробуйте указать опцию `--color=auto`: 

```sh
ls --color=auto
``` 

А вот жесткие ссылки никак не выделяются, и визуально нельзя понять: перед нами файл или ссылка по крайней мере. Однако есть дистрибутивы где жесткие ссылки выделяются каким-либо цветом - например, темно-синим. 

Рассмотрим вывод команды `ls -l`:

```sh
ls -l
```


Также найти все символические ссылки можно с помощью команды find: 

```sh
find . -type l
```

Найти с помощью этой команды все символические ссылки на файл "file" можно 
так: 

```sh
find . -lname "file" 
```

С жесткими ссылками все не так просто. Первая колонка вывода команды `ls -l` -
это права доступа. Вторая колонка - счетчик жестких ссылок.


Посмотрим на вывод команды `ls  -i`, которая показывает индексные дескрипторы 
файлов:

```sh
ls -i 
```

Как можно видеть, здесь есть два одинаковых дескриптора и два имени для этого дескриптора. 


#### Удаление файлов и жесткие ссылки


В предыдущем разделе приводился вывод команды `ls` с опцией `-i`. Посмотрите на вывод команды `ls  -l`  -  вторая колонка показывает на inode. По сути, в этом контексте нет особой разницы количество жестких между ссылкой и файлом. Вы можете удалить файл file: 

```sh
rm file
```

```sh
ls -l
``` 

И вы увидите, что счетчик ссылок оказался уменьшен на единицу. Но ваши данные 
останутся в файле hardlink, и вы сможете их прочитать. Почему же файл file был удален, если на него указывала жесткая ссылка hardlink? Потому, что жесткая  ссылка указывает не на имя файла, а на inode! А ведь индексный дескриптор остался, и он не будет удален, пока счетчик жестких ссылок больше `0`! 

Именно поэтому, если вы хотите защитить файл от удаления путем создания на него жесткой ссылки, это неправильный вариант. Для защиты файла от случайного удаления используйте команду `chattr +i`:

```sh
touch  f 
```

```sh
sudo chattr +i  f 
```

```sh
rm f 
```


Удалить файл можно, только сняв флаг i: 
```sh
chattr -i f 
```

Кстати, после удаления файла file, на который указывала символическая ссылка symlink, последняя превращается в «битую» ссылку - в отмечается красным цветом на черном фоне. Таким образом, превращается в «битую» по следующим причинам: 
- удаление целевого файла; 
- переименование целевого файла; 
- переименование элементов пути к целевому файлу. Например на файл /home/den/links/file, а потом каталог links был переименован в test.

Возвращаемся к жестким ссылкам - найти все жесткие ссылки на файл можно командой find с опцией -samefile: 

```sh
find . -samefile file 
```

#### Разница между копированием и созданием жесткой ссылки 

Учитывая, что жесткая ссылка - это практически то же что и файл, возни­кает вопрос: когда лучше копировать файл, а когда создавать? 

Все зависит от поставленных задач. Ведь жесткая ссылка ссылается на тот же inode, что и файл, следовательно, при изменении файла (или ссылки) изменяется и содержимое файла. Если же вы создаете копию файла, другой inode и, следовательно, изменение копии никак не отразится на оригинале  и наоборот.


#### Права доступа и атрибуты файла. Команды chown, chmod и chattr 
#### Права доступа к файлам и каталогам 

Для каждого каталога и файла вы можете задать права доступа. Точнее, права доступа автоматически задаются при создании каталога/файла, a вы при необходимости можете их изменить. Какая может быть необходимость? Например, вам нужно чтобы к вашему файлу-отчету смогли получить доступ пользователи члены вашей группы. Или вы создали обычный текстовый файл, содержащий инструкции командного интерпретатора. Чтобы этот файл стал сценарием, вам нужно установить право на выполнение для этого файла. 

Существуют три права доступа чтение (r), запись (w), выполнение (x). Для каталога право на выполнение означает право на просмотр содержимого каталога.

Вы можете установить разные права доступа для владельца (т. e. для себя), для группы владельца (т. e. для всех пользователей входящих в одну с владельцем) и для прочих пользователей. Пользователь root может получить доступ к любому файлу или каталогу вне зависимости от прав, которые вы установили.


Чтобы просмотреть текущие права доступа, введите команду: 

```ls
ls -l <имя файла/каталога> 
```

Например, 

```
ls -l video.txt 
```

В этой строке фрагмент `-r--r-----` описывает права доступа: 
- первый символ это признак каталога. Сейчас перед нами файл Если бы перед нами был каталог то первый символ был бы символом а (от directory); 
- последующие три символа (г--) определяют права доступа владельца файла или каталога Первый символ это чтение, второй запись, третий выполнение Как можно видеть, владельцу разрешено только чтение этого файла, запись и выполнение запрещены, поскольку в правах доступа режимы w и x не определены; 
- следующие три символа (r--) задают права доступа для членов группы владельца. Права такие же, как и y владельца: можно читать файл, но нельзя изменять или запускать;
- последние три символа (---) задают права доступа для прочих пользователей. Прочие пользователи не имеют права ни читать, ни изменять, ни выполнять файл. При попытке получить доступ к файлу они увидят сообщение Access denied.

```
ПОЛНЫЙ ВЫВОД КОМАНДЫ LS 
	Как можно видеть, после символов прав доступа команда `ls` выводит имя владельца файла, имя группы владельца, размер файла, дату и время создания, а также имя файла.
```

Права доступа задаются командой chmod. Существуют два способа указания прав  
доступа: символьный (когда указываются символы, задающие право доступа r  
w, х ) и абсолютный.

Так уж заведено, что в мире UNIX-подобных систем чаще пользуются абсолютным  
методом. Разберемся, в чем он заключается, и рассмотрим следующий набор прав  
доступа: 

`rw-r-----` 

Этот набор предоставляет владельцу право чтения и модификации файла (rw-),  
запускать файл владелец не может. Члены группы владельца могут только проcматривать файл (r--), a все остальные пользователи не имеют вообще никакого доступа к файлу.

Возьмем отдельный набор прав, например, для владельца: `rw-`.  
Чтение разрешено мысленно записываем `1` запись разрешена запоминаем еще 1, a вот выполнение запрещено, поэтому запоминаем `0`. Получается число `110`. Если перевести число 110 из двоичной системы в восьмеричную получится число 6. 


[[95c266b384681539b9b30272c8975935_MD5.jpeg|Open: Pasted image 20250402145155.png]]
![[95c266b384681539b9b30272c8975935_MD5.jpeg]]

Аналогично произведем разбор прав для членов группы владельца. Получится двоичное 100, т. е. восьмеричное 4 третьим набором (---) все вообще просто это `000`,  т. e. `0`  

Записываем полученные числа в восьмеричной системе в порядке: владелец  - 
группа - остальные. Получится число `640` это и есть права доступа. Для того  
чтобы установить эти права доступа, выполните команду:  

```sh
chmod 640 <имя файла>  
```

**Наиболее популярные права доступа:**  
- 644 - владельцу можно читать и изменять файл, остальным пользователям  
только читать;
- 666 - читать и изменять файл можно всем пользователям;
- 777 - всем можно читать, изменять и выполнять файл. 

```
ПРАВО ВЫПОЛНЕНИЯ ДЛЯ КАТАЛОГА 
это право просмотра оглавления ка­ Напомню, что для каталога право выполнения -
талога. 
```


Иногда символьный метод оказывается проще. Например, чтобы файл script сделать 
исполнимым, можно отдать команду: 

```sh
chmod +х script 
```

Для того чтобы снять право выполнения, указывается параметр -х: 

```
chmod -х script 
```

Подробнее о символьном методе вы сможете прочитать в руководстве по команде 
chrnod (выполнив команду man  chrnod). 


#### Смена владельца файла 
Если вы хотите «подарить» кому-то файл, т. е. сделать какого-либо пользователя 
владельцем файла, вам нужно использовать команду **chown**: 
```sh
chown пользователь файл
``` 

```
ПОСЛЕДСТИВИЯ ИЗМЕНЕНИЯ ВЛАДЕЛЬЦА ФАЙЛА 
Возможно, что после изменения владельца файла вы сами не сможете получить к не­
му доступ, ведь владельцем будете уже не вы. 
```

#### Специальные права доступа (SUID и SGID) 
Мы рассмотрели обычные права доступа к файлам, но в Linux есть еще так назы­ваемые специальные права доступа: **SUID**  (Set User 1D  root) и **SGID** (Set Group 1D root). 

Эти права доступа позволяют обычным пользователям запускать программы, тре­бующие для своего запуска привилегий пользователя **root**. Например, какой-нибудь демон/сервис требует привилегий root, но чтобы каждый раз при использовании не входить в систему под именем root, достаточно установить специальные права доступа для демона/сервиса. Делается это так: 
```
chrnod  u+s  /usr/sbin/pppd
```
Однако не нужно увлекаться такими решениями, поскольку каждая программа, для 
которой установлен бит SUID, является потенциальной «дырой» в безопасности 
системы. Для выполнения программ, требующих прав **root**, намного рациональнее 
использовать программы sudo и su ( описание которых можно получить по командам man  sudo И man  su).  В основном sudo.

#### Атрибуты файла. Запрет изменения файла 
С помощью команды chattr можно изменить атрибуты файла. Параметр `+` устанав­ливает атрибут, а параметр `-` атрибут снимает. Например: 

```sh
chattr +i  /boot/grub/menu.lst
``` 

Эта команда устанавливает атрибут i, запрещающий любое изменение, переимено­ вание и удаление файла. У становить этот атрибут, равно как и снять его, имеет право только суперпользователь или процесс с возможностью САР _ LINUX _ rммuтАВLЕ. 
Чтобы изменить файл, нужно очистить атрибут с помощью команды: 
```sh
chattr -i /boot/gruЬ/menu.lst 
```
Если установить атрибут j, то все данные, прежде чем быть записанными непо­cредственно в файл, будут сохранены в журнал файловой системы. Этот атрибут имеет смысл только тогда, когда файловая система смонтирована с опциями data=ordered или data=writeback (**Это далее**). Когда файловая система смонтиро­вана с опцией data=journal, установка атрибута j данные файла и так уже журналлируются. 

**Рассмотрим еще несколько атрибутов:** 

- когда для файла установлен атрибут А (прописная буква!), тогда не происходит обновление записи atime (в ней хранится время доступа к файлу). Это позволяет избежать лишних дисковых операций ввода/вывода, что полезно для медленных компьютеров; 
- если для файла установлен атрибут а, в файл можно только добавлять данные. Этот атрибут имеет право установить (или очистить) суперпользователь или процесс с возможностью САР - LINUX - IММUТАВLЕ; 
- атрибут с заставляет систему упаковывать (сжимать) содержимое файла, что по­зволяет сэкономить место на диске. При записи в файл информация автоматически сжимается и записывается на диск в уже сжатом виде, при чтении из этого файла возвращаются несжатые данные; 
- когда изменяется каталог с установленным атрибутом о, изменения сразу же записываются на диск. Это эквивалентно применению опции монтирования 
dirsync; 
- если для файла установлен атрибут d, для него не будет выполнено резервное копирование программой dump; 
- при изменении файла с установленным атрибутом s его данные синхронно запи­сываются на диск. Это аналогично опции монтирования sync к подмножеству файлов; 
- когда удаляется файл с установленным атрибутом s, система выполняет обнуле­ние его блоков и запись их обратно на диск; 
- при удалении файла с атрибутом u его содержимое сохраняется на диске, что позволяет впоследствии легко восстановить этот файл; 
- атрибуты х и z используются экспериментальными заплатками сжатия для служебных целей.  

Установить любой атрибут можно командой `chattr`, a просмотреть командой  
`lsattr`. Об остальных атрибутах вы сможете прочитать в справочной системе, вы-  
полнив команду: **man chattr**  

#### Команды поиска файлов: find, which и locate  

Для поиска файлов в Linux служит команда **find** Это весьма мощная утилита со  
сложным синтаксисом, и далеко не всегда она нужна обычному пользователю На-  
много проще установить файловый менеджер mc и использовать встроенную в него  
функцию поиска  

Но команду **find** мы все же рассмотрим по крайней мере ее основы Синтаксис  
команды следующий:  

```sh
find список_поиска выражение  
```

Мощность команды **find** заключается во множестве самых разных параметров  
поиска, которые из-за их количества не так-то просто запомнить Команда также  
может выполнять операции над найденными файлами Например, вы можете найти  
временные файлы и сразу удалить их.

Все опции команды find мы изучать не станем это вы можете сделать самостоятельно с помощью команды **man find**. Здесь же мы приведем лишь несколько примеров ее использования:  

- найти файлы с именем a.out (точнее, в имени которых содержится строка "a.out"), поиск начать с корневого каталога (/)

```sh
find / -name a.out
```  

- найти файлы по маске txt  
```sh
find / -name '*.txt'  
```

- найти файлы нулевого размера, поиск начать с текущего каталога (.):  
```sh
find . -size 0  
```

Кстати, для поиска пустых файлов намного проще использовать параметр  
empty:  
```sh
find . -empty
```  
- найти файлы, размер которых от 100 до Гбайт поиск производить в домашнем  
каталоге и всех его подкаталогах:  
```sh
find ~ -size +100M -size -1G
```  
- найти все временные файлы и удалить их (для каждого найденного файла будет  
запущена команда rm):  
```sh
find / -name *.tmp -ок rm {} \;
```

Вместо параметра -ок можно использовать параметр exec, который также  
запускает указанную после него команду, но не запрашивает подтверждение  
выполнения этой команды для каждого файла;  

- найти все файлы (не каталоги - это определяет параметр -type f) и установить  
для них права 644 (поиск начинается с текущего каталога `.` ):  
```sh
find . -type f -ехес chmod 0644 {} \;
```

Для поиска файлов, кроме команды find, можно использовать команды **which** и  
**locate**. Первая выводит полный путь к программе или к сценарию, если программа  
или сценарий находится в списке каталогов, заданном в переменной окружения  
**PATH**: 

```sh
which sendmail
```  

Команда **locate** ищет в базе данных демона located файлы, соответствующие задан-  
ному образцу. Недостаток этой команды в том, что located имеется далеко не во  
всех дистрибутивах, поэтому команды locate y вас может и не быть. Зато если  
located имеется и запущен, поиск файлов будет осуществляться быстрее, чем с по-  
мощью **find**.

### Монтирование файловых систем  
#### Команды mount и umount  
Чтобы работать с какой-либо файловой системой необходимо примонтировать ее  
к корневой файловой системе. Например, вставив в разъем USB флешку, нужно  
подмонтировать файловую систему флешки к корневой файловой системе толь-  
ко так мы сможем получить доступ к файлам и каталогам, которые на этой флешке  
записаны. Аналогичная ситуация с жесткими, оптическими дисками и другими но-  
сителями данных.

Если вы хотите заменить сменный носитель данных (флешку, компакт-диск), вам  
нужно сначала размонтировать файловую систему затем извлечь носитель данных,  
установить новый и заново смонтировать файловую систему. В случае с флешкой  
о размонтировании должны помнить вы сами поскольку при этом выполняется  
синхронизация буферов ввода/вывода и файловой системы, т. e. данные физически  
записываются на носитель, если это еще не было сделано. A компакт-диск система  
не разрешит вам извлечь, если он не размонтирован. В свою очередь, размонтировать файловую систему можно только тогда, когда ни один процесс ее не использует.

При завершении работы системы (перезагрузке, выключении компьютера) размонтирование всех файловых систем выполняется автоматически.

Команда монтирования (ее нужно выполнять с привилегиями **root**) выглядит так:  
```sh
mount [опции] <устройство> <точка монтирования> 
```

Здесь **точка монтирования** это каталог, через который будет осуществляться доступ к монтируемой файловой системе. Например, если вы подмонтировали компакт-диск к каталогу **/mnt/cdrom**, то получить доступ к файлам и каталогам записанным на компакт-диске, можно будет через точку монтирования (именно этот каталог: **/mnt/cdrom**). Точкой монтирования может быть любой каталог корневой файловой системы, хоть **/ааа-111** Главное, чтобы этот каталог существовал на момент  
монтирования файловой системы.

В некоторых современных дистрибутивах запрещен вход в систему под именем  
суперпользователя - **root**. Поэтому для выполнения команд с привилегиями **root**  
вам нужно использовать команду **sudo**. Например, чтобы выполнить команду монтирования привода компакт-диска вам нужно ввести команду:

```sh
sudo mount /dev/scd0 /mnt/cdrom
```  

Перед выполнением команды **mount** команда **sudo** попросит вас ввести пароль **root**.

Если введенный пароль правильный, то будет выполнена команда **mount**.  

Для размонтирования файловой системы служит команда **umount**:  
```sh
umount <устройство или точка монтирования> 
``` 

#### Файлы устройств и монтирование 

Мы уже говорили о файлах устройств. Здесь мы вернемся к ним снова,  
но в контексте монтирования файловой системы.

Как уже было отмечено, для Linux нет разницы между устройством и файлом.
Все устройства системы представлены в корневой файловой системе как обычные  
файлы. Например, `/dev/fd0` это ваш дисковод для гибких дисков (ведь вы всё  
еще помните, что это за устройство?), `/dev/sda` жесткий диск. Файлы устройств  
хранятся в каталоге **/dev**.

**Жесткие диски**  
жесткими дисками сложнее всего, поскольку одно и то же устройство может в разных версиях одного и того же дистрибутива называться по-разному. Например, диск, подключенный как первичный мастер, в Fedora 5 назывался **/dev/hda**, a начиная с Fedora 8, он называется **/dev/sda**. Раньше накопители, подключающиеся к интерфейсу IDE (PATA), назывались **/dev/hdx**, a накопители SCSI/SATA **/dev/sdx**.  

После внедрения менеджера устройств **udev** `(это менеджер устройств впервые появившийся в ядре Linux начиная версии 2.6 Пришел на смену более громоздкой псевдофайловой системе **devfs** Управляет всеми манипуляциями файлами из каталога /dev) и принятия глобального уникального)` идентификатора устройств **(UUID)** все дисковые устройства, вне зависимости от интерфейса подключения PATA, SATA, SCSI), называются /dev/sdx, где х буква.

Все современные дистрибутивы поддерживают udev и UUID.

SSD-диски, подключаемые по интерфейсу SATA называются аналогично  
/dev/sdx, где x буква. A вот если SSD подключается по интерфейсу NVMe, то  
имя устройства будет /dev/nvmeN где n число (нумерация начинается с 0, t е  
первый NVMе-диск будет доступен под именем /dev/nvme0).

Рассмотрим ситуацию с жесткими дисками чуть подробнее Пусть y нас есть устройство /dev/sda. На жестком диске, может быть несколько разделов.
Рассмотрим ситуацию, когда на диске имеются три раздела (логических диска), которые в Windows называются C:, D: и E: Диск C: обычно является загрузочным  
(активным), поэтому этот раздел будет записан в самом начале диска. Нумерация  
разделов жесткого диска в Linux начинается с 1, и в большинстве случаев диску C:  
будет соответствовать имя **/dev/sda1** - первый раздел на первом жестком диске.  
В случае с [NVMe-накакопителями](https://ru.wikipedia.org/wiki/NVM_Express) первый раздел будет называться **/dev/nvme0pl**.  

Резонно предположить, что двум оставшимся разделам (D: и E:) будут присвоены  
имена **/dev/sda2** и **/dev/sda3** Это может быть и так и не так. Как известно, на жестком  
диске могут существовать или четыре первичных раздела, или три первичных и  
один расширенный. В расширенном разделе могут разместиться до 11 логических  
дисков (разделов). Таким образом, раздел может быть первичным (primary  
partition), расширенным (extended partition) или логическим (logical partition).

Для возможных четырех первичных разделов диска b Linux зарезервированы номера 1, 2, 3, 4. Если разделы D: и E: нашего диска первичные то, да им будут присвоены имена /dev/sda2 и /dev/sda3 Но в большинстве случаев эти разделы являются  
логическими и содержатся в расширенном разделе Логические разделы именуются,  
начиная с 5, a это означает что если разделы D: и E: логические, то им будут присвоены имена /dev/sda5 и /dev/sda6 соответственно.

Узнать номер раздела очень просто достаточно запустить утилиту работающую  
таблицей разделов диска. В Fedora придется использовать стандартный **fdisk** или  
**cfdisk** (он немного удобнее), a в Debian/Ubuntu **GParted** (кстати, очень удобное  
средство разметки диска). Впрочем, в большинстве случаев удобнее всего запустить (от имени root) утилиту **fdisk** она есть в любом дистрибутиве Linux.

Чтобы узнать номера разделов первого жесткого диска (/dev/sda), введите команду:  

```sh
/sbin/fdisk /dev sda
```

#### Приводы оптических дисков  
Приводы для чтения/записи CD/DVD называются **/dev/scdN**, где n номер устройства. Если y вас только один привод CD/DVD то его имя будет **/dev/scd0**.

Монтирование привода для чтения оптических дисков осуществляется командой:  
```sh
mount /dev/scd0 /mnt/cdrom  
```

После этого обратиться к файлам записанным на диске, можно будет через каталог  
**/mnt/cdrom**. Каталог должен существовать.

#### Флешки и внешние жесткие диски  

Флешка (флеш-память) и внешние USВ-диски определяются системой как обычные  
жесткие диски. Предположим, что в компьютере установлен всего один жесткий  
диск, тогда ему соответствует имя устройства **/dev/sda**.

Когда вы подключите флешку или внешний жесткий диск, этому устройству будет присвоено имя **/dev/sdb**. Обычно на флешке или USВ-диске всего один раздел, по- этому подмонтировать устройство можно командой: 

```sh
mount /dev/sabl /mnt/usbdisk
``` 
В современных дистрибутивах флешки, внешние жесткие диски и диски CD/DVD монтируются автоматически (правда не к подкаталогу **/mnt** чаще для этих целей используется каталог **/media**, но все зависит от дистрибутива), и вся информация на этот счет здесь приведена для общего развития или на аварийный случай, когда вы загрузите систему в одно-пользовательском режиме и вам придется монтировать носители вручную 


#### Опции монтирования файловых систем 

Теперь, когда мы знаем номер раздела, можно подмонтировать его файловую систему. Делается это так: 

```sh
mount <раздел» <точка монтирования>
```

Например: 
```sh
mount /dev/sda5 /mnt/win_d
``` 

У команды **mount** довольно много опций но на практике наиболее часто используются только некоторые из них: -t, -г, -w, -a. 
- Параметр -t позволяет задать тип файловой системы. Обычно программа сама определяет файловую систему, но иногда это у нее не получается. Тогда мы должны ей помочь. Формат этого параметра следующий: 

```
mount -t <файловая система> <устройство> <точка монтирования>
``` 

Например: 
```sh
mount -t iso9660 /dev/sdc /mnt/cdrom 
```

Вот опции для указания наиболее популярных монтируемых файловых систем: 
- ext2, ext3, ext4 файловая система Linux; 
- iso9660 указывается при монтировании CD-ROM; 
- vfat FAT, FAT32 (поддерживаются Windows 9х, ME, XP); 
- ntfs NT File System (поддерживаются Windows NT XP 7, 8 10, 11) Будет использована стандартная поддержка NTFS, при которой NTFS-раздел доступен только для чтения; 
- ntfs-3g будет запущен модуль ntfs-3g, входящий в большинство современных дистрибутивов. Этот модуль позволяет производить запись информации на NTFS-разделы. 

Если вы не можете смонтировать NTFS-раздел с помощью опции ntfs-3g, вероятнее всего, он был неправильно размонтирован (например, работа Windows не была завершена корректно). В этом случае для монтирования раздела нужно использовать опцию `-о force`, например: 

```sh
sudo mount -t ntfs-Зg /dev/sdb1 /media/usb -о force 
```

- Параметр **-r** монтирует указанную файловую систему в режиме «только чтение». 
- Параметр **-w** монтирует файловую систему в режиме «чтение/запись». Этот параметр используется по умолчанию для файловых систем, поддерживающих запись (например, NTFS по умолчанию запись не поддерживает, как и файловые системы СD/DVD-дисков). 
- Параметр **-а** служит для монтирования всех файловых систем, указанных в фай­ле **/etc/fstab** (кроме тех, для которых указано noauto, - такие файловые системы нужно монтировать вручную). При загрузке системы тогда вызывается команда mount с параметром -а. 

#### Монтирование разделов при загрузке 
Если вы не хотите при каждой загрузке монтировать постоянные файловые системы 
(например, Windows-paздeлы), то нужно прописать их в файле /etc/fstab. Обратите 
внимание - в этом файле не следует прописывать файловые системы сменных носи­телей (дисковода, СD/DVD-привода, флешки). Следует отметить, что программы 
установки некоторых дистрибутивов читают таблицу разделов и автоматически заполняют файл **/etc/fstab** - в результате все ваши Windows-paздeлы оказываются дос­тупны сразу после установки системы. К сожалению, не все дистрибутивы могут 
похвастаться такой интеллектуальностью, поэтому вам нужно знать формат файла 
fstab: 
```
устройство точка_монтирования тип_ФС опции флаг_РК флаг_проверки
``` 
Здесь: `тип_ФC` - это тип файловой системы, а `флаг_РК` - флаг резервного копирования. Если он установлен (1), то программа dump заархивирует эту файловую систе­му при создании резервной копии. Если не установлен (0), то резервная копия ее 
создаваться не будет. `Флаг_проверки` устанавливает, будет ли эта файловая система 
проверяться на наличие ошибок программой fsck. Проверка производится в двух 
случаях:

- если файловая система размонтирована некорректно; 
- если достигнуто максимальное число операций монтирования для этой файло­вой системы. 

Поле `опции` содержит важные параметры файловой системы. Некоторые из них представлены в таблице ниже.

```
РЕДАКТИРОВАНИЕ ФАЙЛА /ETC/FSTAB

Редактировать файл /etc/fstab, как и любой другой файл из каталога letc, можно в лю­бом текстовом редакторе (например, gedit, kate), но перед этим нужно получить права root (командой su или sudo). 
```

[[909c5ec42ed29608b12814bb9e9faf85_MD5.jpeg|Open: Pasted image 20250405172006.png]]
![[909c5ec42ed29608b12814bb9e9faf85_MD5.jpeg]]

**Рассмотрим небольшой пример:** 

```sh
/dev/sdc  /mnt/cdrom auto umask=0,user,noauto,ro,exec 0 0 
```

```sh
/dev/sda1  /mnt/win_c vfat unask=0,utf8 0 0 
```

Первая строка - это строка монтирования файловой системы компакт-диска, а 
вторая - строка монтирования диска С:. 
- Начнем с первой строки. **/dev/sdc** - это имя устройства CD-ROM. Точка монти­рования - **/mnt/ cdrom**. Понятно, что этот каталог должен существовать. Обрати­те внимание - в качестве файловой системы не указывается жестко ISO 9660, по­скольку компакт-диск может быть записан в другой в качестве типа файловой системы задано **auto**, т. е. автоматическое определение. 
- Далее идет длинный набор опций. Ясно, что umask установлен в ноль, поскольку файловая система компакт-диска не поддерживает права Linux. Параметр **user** говорит о том, что эту файловую систему можно монтировать обычному пользователю. Параметр **noauto** запрещает монтирование этой файловой системы, что правильно, - ведь на момент может и не быть компакт-диска. Опция **ro** разрешает «только чтение», а **ехес** разрешает запускать исполняемые файлы. Понятно, что компакт-диск не нуждается ни в проверке, ни в создании резервной копии, поэтому два последних флага равны нулю.

- Вторая строка проще. Первые два поля - это устройство и точка монтирования. Третье - тип файловой системы. Файловая система постоянна, поэтому можно явно указать тип файловой системы (vfat), а не auto. Опция umask, как и в предыдущем случае, равна нулю. Указание опции utf8 позволяет корректно отображать русскоязычные имена файлов и каталогов. 

#### Подробно о UUID и файле /etc/fstab 
Пока вы еще не успели забыть формат файла **/etc/fstab**,  поговорим о  UUID (Universally Unique ldeпtifier), или о длинных именах дисков. В некоторых дистри­тивах, например в Ubuntu, вместо имени носителя (первое поле файла fstab) ука­зывается его ID, поэтому файл fstab выглядит устрашающе, вот так: 

```txt
/dev/sda6 
UUID=lf049af9-2bdd-43bf-al6c-ff5859a4116a / ехtЗ defaults 0 1 
/dev/sda1 
UUID=45AE-84D9 /media/sda1 vfat defaults,utf8,umask=007 0 0
```

В openSUSE идентификаторы устройств указываются немного иначе: 
```txt
/dev/disk/by-id/scsi-SATA_WDC_WD1600JВ-OO_WD-WCANM7959048-part5 / 
ехtЗ acl,user_xattr 1  1 
/dev/disk/by-id/scsi-SATA_WDC_WD1600JВ-OO_WD-WCANM7959048-part7 swap  swap 
defaults 0 0 
```
Понятно, что использовать короткие имена вроде /dev/sda1 намного проще, чем 
идентификаторы в стиле **1f049af9-2bdd-43Ы-alбc-ff5859a4116a**. Использование 
имен дисков еще никто не отменял, поэтому вместо идентификатора носителя мо­жете смело указывать его файл устройства - так вам будет значительно проще!

Но все же разбираться в соответствии длинных имен дисков коротким именам устройств следует - ведь система использует именно эти имена, а в файле /etc/fstab не всегда указывается, какой идентификатор какому короткому имени устройства принадлежит (или указывается, но не для всех разделов).

Узнать длинные имена устройств можно с помощью простой  команды: 
```
ls  -1  /dev/disk/by-uuid/ 
```

```
sudo blkid
```

Спрашивается, зачем было вводить длинные имена, если короткие имена удобнее, во всяком случае для пользователя? Оказывается, разработчики Linux в первую очередь и заботились о пользователях. Возьмем обычный IDE-диск. Как известно, его можно подключить либо к первичному (primary), либо ко вторичному (secondary), если он есть, контроллеру. При этом согласно положению перемычки  выбора режима винчестера может быть либо главным устройством (master), либо подчиненным (slave). Таким образом, в зависимости от контроллера, к которому подключается диск, изменяется его короткое имя: sda (primary master), sdb (primary slave), sdc (secondary master), sdd (secondary slave). То же самое происходит с SATA/SCSI-винчейстерами - при изменении параметров подключения изменяется и короткое имя устройства.