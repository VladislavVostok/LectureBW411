#### bash: основные сведения

bash - это наиболее часто использующаяся командная оболочка (командный интерпретатор) Linux. Основное предназначение bash выполнение команд, введенных пользователем. Пользователь вводит команду, bash ищет программу, соответствующую команде, в каталогах, указанных в переменной окружения PATH. Если  такая программа найдена, то bash запускает ее и передает ей введенные пользователем параметры. B противном случае выводится сообщение о невозможности выполнения команды.

Кроме bash в Linux существуют и другие оболочки: **sh**, csh, ksh, **zsh**, tesh' и пр. Все  
командные оболочки, установленные в системе, прописаны в файле /etc/shells.  

Так же есть **tmux**, который представляет собой терминальный мультиплексор, позволяющий работать с несколькими сессиями в одном окне c одной стороны, такое решение интересно тем, что дает возможность создать в консольном режиме как бы несколько «окон». Подробнее о [Tmux](https://habr.com/ru/post/327630/).

файл **/etc/shells**:
```txt
/Ьin/sh 
/Ьin/bash
/usr/Ьin/sh 
/usr/Ьin/bash 
/usr/Ьin/tmux 
/Ьin/tmux 
```

С точки зрения пользователя, прописанные в файле /etc/shells оболочки мало чем 
друг от друга отличаются, поскольку все они позволяют выполнять введенные пользователем команды. Но оболочки служат не только для выполнения команд, а 
еще и для автоматизации задач с помощью сценариев, и основное их различие за­ключается в синтаксисе языка описания сценариев. Мы поговорим о создании basg-сценариев, поскольку оболочка bash самая популярная.

При запуске оболочка bash выполняет сценарий .bashrc, обычно расположенный в домашнем каталоге пользователя ( этот файл не обязателен и может там отсутствовать). В файле этого сценария можно указать команды, которые нужно выполнить сразу после входа пользователя в систему. 

В файле .bash_histoгy ( он тоже находится в домашнем каталоге) хранится история команд, введенных пользователем, - открыв его, вы можете просмотреть свои ко­манды, которые накануне вводили. 

#### Автоматизация задач с помощью bash

Представим, что нам нужно выполнить резервное копирование всех важных фай­
лов, для чего создать архивы каталогов /etc, /home и /usr. Понятно, что понадобятся три команды вида: 

```sh
tar -cvjf имя_архива.tаr.Ьz2 каталог 
```

Затем надо будет записать все эти три файла на внешний носитель флешку или внешний USВ-диск, хотя с точки зрения системы особой разницы нет. Ничего страшного, если выполнять эту операцию раз в месяц или хотя бы раз в неделю. Но представьте, что вам нужно делать ее каждый день или даже несколько раз в день! 

Такая рутинная работа вам быстро надоест. А ведь можно написать сцена­рий, который сам будет создавать резервные копии и записывать их на внешний носитель! И все, что для этого потребуется, - это проверить перед запуском сценария наличие на этом носителе достаточного количества свободного места. 

Можно пойти и иным путем. Написать сценарий, который будет делать резервные копии системных каталогов и записывать их на другой раздел жесткого диска. Ведь не секрет, что резервные копии делаются не только на случай сбоя системы, но и для защиты от некорректного изменения данных пользователем. Бывают сбои или взломы сайтов у хостинг провайдера, их можно попросил сделать откат и можно быть приятно удивленным, когда предоставляют на выбор три резервные копии, осталось лишь выбрать наиболее подходящую. Администраторы провайдера не занимаются целый день, копированием  домашних каталогов пользователей. Поэтому автоматизация штука полезная, и любому  администратору нужно знать, как автоматизировать свою рутинную работу.

#### С днём Космонавтики!

Итак, напишем наш первый сценарий, по традиции выводящий всем известную фразу:  «С днём Космонавтики!» . Вся работа со сценариями выполняется обычно в консоли (или в терминале).  

```sh
#!/bin/bash  
echo "С днём Космонавтики!"
```  

Первая строка нашего сценария это указание, что он должен быть обработан  
программой **/bin/bash**. Обратите внимание если между символами # и ! окажется пробел, то эта директива не сработает, поскольку будет воспринята как обычный комментарий, который, как вы уже догадались, начинается с решетки:  

```sh
# Комментарий
```  

Вторая строка это оператор **echo**, выводящий нашу строку.

Теперь сохраните сценарий под именем **hello** и введите следующую команду (она  сделает наш сценарий исполнимым): 

```sh
chmod +x hello
```  

Для запуска сценария введите команду:  
```sh
./hello
```  
и на экране вы увидите строку:  

```txt
С днём Космонавтики!
```

Чтобы вводить для запуска сценария просто hello (без 1), сценарий нужно скопировать в каталог /usr/bin (точнее, в любой каталог из переменной окружения PATH):  

```sh
cp ./hello /usr/bin
```

#### Использование переменных  в собственных сценариях  

В любом серьезном сценарии вы не обойдетесь без использования переменных. 
Переменные можно объявлять в любом месте сценария но до места их первого  применения. Рекомендуется объявлять переменные в самом начале сценария чтобы  потом не искать, где вы объявили ту или иную переменную.

Для объявления переменной используется следующая конструкция:  
```txt
переменная=значение
``` 

Пример объявления переменной:  

```sh
ADDRESS=www.yandex.ru  
echo $ADDRESS
```  

Обратите внимание на следующие моменты:  
- при объявлении переменной знак доллара не ставится, но он обязателен при использовании переменной;  
- при объявлении переменной не должно быть пробелов до и после знака `=`.

Значение для переменной указывать вручную не обязательно его можно прочитать с клавиатуры:  
```
read ADDRESS
```

или со стандартного вывода программы: 

```
ADDRESS=`hostname`
```

Как можно видеть, чтение значения переменной с клавиатуры осуществляется  с помощью инструкции read (при этом указывать символ доллара не нужно). Вторая приведенная здесь команда устанавливает в качестве значения переменной ADDRESS вывод команды hostname.  
В Linux часто используются переменные окружения. Это специальные переменные,  
содержащие служебные данные. Вот примеры некоторых часто используемых переменных окружения:  
- HOME - домашний каталог пользователя, который запустил сценарий;  
- RANDOM - случайное число в диапазоне от 0 до 32 767;
- UID - ID пользователя, который запустил сценарий;  
- PWD - текущий каталог;  

Для установки собственной переменной окружения используется команда **export**:  

```
# присваиваем переменной значение  
$ADDRESS=WWW bhv ru  
# экспортируем переменную делаем ее переменной окружения,  
# после этого переменная ADDRESS будет доступна других сценариях  
export $ADDRESS
```

#### Передача параметров сценарию  

Очень часто сценариям нужно передавать различные параметры например, для задания режима работы или указания имени файла каталога. Для передачи параметров используются следующие специальные переменные:

- `$0` - содержит имя сценария;  
- `$n` - содержит значение параметра (п номер параметра);  
- `$#` - позволяет узнать количество параметров которые были переданы  

Рассмотрим небольшой пример обработки параметров сценария. 
```
# сценарий должен вызываться так:  
# имя сценария параметр  
# анализируем первый параметр

case "$1 in  
	start) 
		# действия при получении параметра start  
		echo Запускаем сетевой сервис  
		;;
	stop) 
		# действия при получении параметра stop  
		echo "Останавливаем сетевой сервис  
		;;
*)
		# действия в остальных случаях  
		# выводим подсказку том, как нужно использовать сценарий,  
		# и завершаем работу сценария  
echo "Usage: $0 {start|stop}"  
		exit 1
		;;
esac  
```

#### Массивы  
Интерпретатор bash позволяет использовать массивы. Массивы объявляются подобно переменным. Вот пример объявления массива:  

```sh
ARRAY[0]=1 
ARRAY[1]=2 

echo $ARRAY[0]
```

#### Циклы
Как и в любом языке программирования, в bash можно использовать *циклы*. Мы рассмотрим циклы **for** и **while**, хотя в bash доступны также циклы **until** и **select**, но они применяются довольно редко.  

Синтаксис цикла for выглядит так:  

```sh
for переменная in список  
do 
команды 
done 
```
В цикле при каждой итерации переменной будет присвоен очередной элемент списка, над которым будут выполнены указанные команды. Чтобы было понятнее, рассмотрим небольшой пример:  

```sh
for n in 1 2 3;  
do 
echo $n;  
done  
```
Обратите внимание: список значений и список команд должны заканчиваться точкой с запятой.

Как и следовало ожидать, наш сценарий выведет на экран следующее:  
```txt
1 
2 
3  
```
Синтаксис цикла **while** выглядит немного иначе:  

```txt
while условие  
do 
команды 
done
``` 

Цикл **while** выполняется до тех пор, пока истинно заданное условие. Подробно об  
условиях мы поговорим в следующем разделе, a сейчас напишем аналог предыдущего цикла, т.е. выведем 1, 2 и 3 но с помощью **while**, a не **for**:  
```sh
n=1  
while [$n -lt  4]  
do echo "$n"  
	n=$(( $n+1 ));  
done
```

#### Условные операторы  
В bash доступны два условных оператора: **if и case**. Синтаксис оператора **if** следующий: 
```sh
if условие_2 then  
	команды_1  
elif условие_2 then  
	команды_2  
elif условие_n then  
	команды_n  
else команды_N+1  
fi 
```

Оператор if в bash работает аналогично оператору if в других языках программирования. Если истинно первое условие, то выполняется первый список команд, иначе проверяется второе условие и т.д. Количество блоков **elif**, понятно, не ограничено. Самая ответственная задача это правильно составить условие. Условия записываются в квадратных скобках. Вот пример записи условий:  
```
# переменная n = 10  
[ N=10 ]
```
```
# переменная n не равна 10  
[ N!=10 ]  
```

Операции сравнения указываются не с помощью привычных знаков больше (>) или  
меньше (<), a с помощью следующих выражений:

- -It - меньше;  
- -gt - больше;  
- -le - меньше или равно;  
- -ge - больше или равно;  
- -eq - равно (используется вместо == )  
Применять эти выражения нужно следующим образом:  

```txt
[переменная  выражение  значение|переменная]  
```
```sh
# Например: N меньше 10  
[ $N -1t 10 ]

# N меньше A  
[ $N -It $A ]  
```  
В квадратных скобках вы также можете задать выражения для проверки существования файла и каталога:

- -е - файл - условие истинно, если файл существует; 
- -d каталог - условие истинно, если каталог существует; 
- -х файл - условие истинно, если файл является исполнимым.
С оператором **case** мы уже немного знакомы, но сейчас рассмотрим его синтаксис подробнее: 

```
case переменная iп 
значение_1) команды_1 ;; 
значение_N) команды_N ;; 
*) команды_по_умолчанию ;; 
esac
```

Значение указанной переменной по очереди сравнивается с приведенными значе­ниями (значение_1, значение_N). Если есть совпадение, то будут выполнены команды, соответствующие значению. Если совпадений нет, то будут выполнены команды по умолчанию.


#### Примеры

```sh
#!/Ьin/bash 
# Задаем переменную, где вычисляем свободное место на диске /dev/vda2 (в мегабайтах) 
freespace=`df -m | grep "/dev/vda1" | awk '{print $4)'` 
# Если сободного места меньше 3000 МЬ, то отправляем письмо на e-mail. 
if  [  $freespace -lt 3000  ]; 
then 
echo  "Warning! ! !  Out of space  on server.  Freespace  -   "$freespace"МЬ"  |     mail -s "FreeSpase"  admin@example.com 
fi 
```