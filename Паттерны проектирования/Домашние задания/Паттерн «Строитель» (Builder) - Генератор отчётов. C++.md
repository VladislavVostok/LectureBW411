

**Контекст:**

Вы разрабатываете модуль для генерации структурированных текстовых отчётов. Эти отчёты могут быть разных типов (например, Краткий, Подробный, для печати) и должны включать различные компоненты: заголовок, тело с разделами, списки, нижний колонтитул, разделители. Процесс создания отчёта должен быть гибким, позволяя добавлять компоненты в произвольном порядке и количестве. Прямая конкатенация строк сделает код неуправляемым.

**Задача:**

Реализовать паттерн «Строитель» для пошагового создания сложных текстовых отчётов.

**Детали реализации:**

- **Продукт (Report):**
    

Класс, представляющий готовый отчёт. Хранит сгенерированную строку и может предоставлять методы для её получения (getResult()) и, например, подсчета слов (getWordCount()).

  
  

- **Абстрактный Строитель (IReportBuilder):**
    

Интерфейс, определяющий все возможные шаги для построения отчёта. Все методы возвращают IReportBuilder& для поддержки цепочки вызовов.

	setTitle(const std::string& title)
	
	addHeader(const std::string& header)
	
	addSection(const std::string& sectionTitle, const std::string& sectionContent)
	
	addBulletList(const std::vector<std::string>& items)
	
	addFooter(const std::string& footer)
	
	build(): Завершает конструирование и возвращает объект Report.

  
  

- **Конкретные Строители (TextReportBuilder, MarkdownReportBuilder, HtmlReportBuilder):**
    

Реализуют интерфейс IReportBuilder, определяя, как именно добавлять каждый компонент. Каждый строитель создаёт отчёт в своём формате.

  
  

TextReportBuilder: Форматирует отчёт простым текстом, используя дефисы, переносы строк, отступы.

MarkdownReportBuilder: Генерирует отчёт с разметкой Markdown (# Заголовок, * элемент списка, **жирный текст**).

HtmlReportBuilder: Строит отчёт в виде HTML-документа (<h1>, <ul>, <li>, <footer>).

  
  

- **Директор (ReportDirector):**
    

Опциональный класс, который инкапсулирует логику создания стандартных типов отчётов, используя любой переданный ему строитель.

  
  

constructShortReport(const std::string& title, const std::string& data)

constructDetailedReport(const std::string& title, const std::vector<std::string>& findings, const std::string& conclusion)

  

**Вывод программы:**

=== Текстовый отчёт (создан через Директора) ===

-----------------------------

АНАЛИЗ ПРОИЗВОДИТЕЛЬНОСТИ

-----------------------------

Метрики:

* Загрузка CPU: 45%

* Потребление RAM: 2.1GB

* Свободно на диске: 15GB

Вывод: Система работает стабильно, рекомендаций нет.

  
  

=== Markdown отчёт (создан вручную) ===

# **Анализ производительности**

## Метрики за последний час

* Загрузка CPU: 45%

* Потребление RAM: 2.1GB

* Свободно на диске: 15GB

### Вывод

Отчёт сгенерирован автоматически

  
  

=== HTML отчёт (создан вручную) ===

<html><body>

<h1><i>Анализ производительности</i></h1>

<h2>Детальный анализ</h2>

<ul><li>Загрузка CPU: 45%</li><li>Потребление RAM: 2.1GB</li><li>Свободно на диске: 15GB</li></ul>

</body></html>

  
  

**Схема:**

Сделать UML диаграмму классов, для этого задания. Задание сдается в виде текстового документа формата .txt (Язык PlantumUML) в корне вашего проекта на C++.