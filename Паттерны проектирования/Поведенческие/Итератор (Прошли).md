**Также известен как**: Iterator

##  Суть паттерна

**Итератор** — это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.


## Проблема

Коллекции — самая распространённая структура данных, которую вы можете встретить в программировании. Это набор объектов, собранный в одну кучу по каким-то критериям.

[[ed5281537349a6009ff7e926aed6c6e6_MD5.jpeg|Open: Pasted image 20250918174640.png]]
![[ed5281537349a6009ff7e926aed6c6e6_MD5.jpeg]]

Большинство коллекций выглядят как обычный список элементов. Но есть и экзотические коллекции, построенные на основе деревьев, графов и других сложных структур данных.

Но как бы ни была структурирована коллекция, пользователь должен иметь возможность последовательно обходить её элементы, чтобы проделывать с ними какие-то действия.

Но каким способом следует перемещаться по сложной структуре данных? Например, сегодня может быть достаточным обход дерева в глубину, но завтра потребуется возможность перемещаться по дереву в ширину. А на следующей неделе и того хуже — понадобится обход коллекции в случайном порядке.

[[3ea661eabdec5bfff81bba2b188d49be_MD5.jpeg|Open: Pasted image 20250918174700.png]]
![[3ea661eabdec5bfff81bba2b188d49be_MD5.jpeg]]

Добавляя всё новые алгоритмы в код коллекции, вы понемногу размываете её основную задачу, которая заключается в эффективном хранении данных. Некоторые алгоритмы могут быть и вовсе слишком «заточены» под определённое приложение и смотреться дико в общем классе коллекции.


##  Решение

Идея паттерна Итератор состоит в том, чтобы вынести поведение обхода коллекции из самой коллекции в отдельный класс.

[[fbaed77974f820a16638da18e49f663c_MD5.jpeg|Open: Pasted image 20250918174717.png]]
![[fbaed77974f820a16638da18e49f663c_MD5.jpeg]]

Объект-итератор будет отслеживать состояние обхода, текущую позицию в коллекции и сколько элементов ещё осталось обойти. Одну и ту же коллекцию смогут одновременно обходить различные итераторы, а сама коллекция не будет даже знать об этом.

К тому же, если вам понадобится добавить новый способ обхода, вы сможете создать отдельный класс итератора, не изменяя существующий код коллекции.

## Структура

![[0e00dd7d8eeda294dfe78590f740b820_MD5.jpeg]]

1. **Итератор** описывает интерфейс для доступа и обхода элементов коллекции.
    
2. **Конкретный итератор** реализует алгоритм обхода какой-то конкретной коллекции. Объект итератора должен сам отслеживать текущую позицию при обходе коллекции, чтобы отдельные итераторы могли обходить одну и ту же коллекцию независимо.
    
3. **Коллекция** описывает интерфейс получения итератора из коллекции. Как мы уже говорили, коллекции не всегда являются списком. Это может быть и база данных, и удалённое API, и даже дерево [[Компановщик (Пройден)]]. Поэтому сама коллекция может создавать итераторы, так как она знает, какие именно итераторы способны с ней работать.
    
4. **Конкретная коллекция** возвращает новый экземпляр определённого конкретного итератора, связав его с текущим объектом коллекции. Обратите внимание, что сигнатура метода возвращает интерфейс итератора. Это позволяет клиенту не зависеть от конкретных классов итераторов.
    
5. **Клиент** работает со всеми объектами через интерфейсы коллекции и итератора. Так клиентский код не зависит от конкретных классов, что позволяет применять различные итераторы, не изменяя существующий код программы.
    
    В общем случае клиенты не создают объекты итераторов, а получают их из коллекций. Тем не менее, если клиенту требуется специальный итератор, он всегда может создать его самостоятельно.


##  Применимость

 **Когда у вас есть сложная структура данных, и вы хотите скрыть от клиента детали её реализации (из-за сложности или вопросов безопасности).**

 Итератор предоставляет клиенту всего несколько простых методов перебора элементов коллекции. Это не только упрощает доступ к коллекции, но и защищает её данные от неосторожных или злоумышленных действий.

 **Когда вам нужно иметь несколько вариантов обхода одной и той же структуры данных.**

 Нетривиальные алгоритмы обхода структуры данных могут иметь довольно объёмный код. Этот код будет захламлять всё вокруг — будь то сам класс коллекции или часть бизнес-логики программы. Применив итератор, вы можете выделить код обхода структуры данных в собственный класс, упростив поддержку остального кода.

 **Когда вам хочется иметь единый интерфейс обхода различных структур данных.**

 Итератор позволяет вынести реализации различных вариантов обхода в подклассы. Это позволит легко взаимозаменять объекты итераторов, в зависимости от того, с какой структурой данных приходится работать.

## Преимущества и недостатки

| Упрощает классы хранения данных.                                          | Не оправдан, если можно обойтись простым циклом. |
| ------------------------------------------------------------------------- | ------------------------------------------------ |
| Позволяет реализовать различные способы обхода структуры данных.          |                                                  |
| Позволяет одновременно перемещаться по структуре данных в разные стороны. |                                                  |


## Конкретно

**Итератор** — это поведенческий паттерн, позволяющий последовательно обходить сложную коллекцию, без раскрытия деталей её реализации.

Благодаря Итератору, клиент может обходить разные коллекции одним и тем же способом, используя единый интерфейс итераторов.

**Применимость:** Паттерн можно часто встретить в C#-коде, особенно в программах, работающих с разными типами коллекций, и где требуется обход разных сущностей.

**Признаки применения паттерна:** Итератор легко определить по методам навигации (например, получения следующего/предыдущего элемента и т. д.). Код использующий итератор зачастую вообще не имеет ссылок на коллекцию, с которой работает итератор. Итератор либо принимает коллекцию в параметрах конструктора при создании, либо возвращается самой коллекцией.


```cs
using System;
using System.Collections;
using System.Collections.Generic;

namespace Iterator_Conceptual
{
    abstract class Iterator : IEnumerator
    {
        object IEnumerator.Current => Current();

        // Возвращает ключ текущего элемента
        public abstract int Key();
        
        // Возвращает текущий элемент.
        public abstract object Current();
        
        // Переходит к следующему элементу.
        public abstract bool MoveNext();
        
        // Перематывает Итератор к первому элементу.
        public abstract void Reset();
    }

    abstract class IteratorAggregate : IEnumerable
    {
        // Возвращает Iterator или другой IteratorAggregate для реализующего
        // объекта.
        public abstract IEnumerator GetEnumerator();
    }

    // Конкретные Итераторы реализуют различные алгоритмы обхода. Эти классы
    // постоянно хранят текущее положение обхода.
    class AlphabeticalOrderIterator : Iterator
    {
        private WordsCollection _collection;
        
        // Хранит текущее положение обхода. У итератора может быть множество
        // других полей для хранения состояния итерации, особенно когда он
        // должен работать с определённым типом коллекции.
        private int _position = -1;
        
        private bool _reverse = false;

        public AlphabeticalOrderIterator(WordsCollection collection, bool reverse = false)
        {
            this._collection = collection;
            this._reverse = reverse;

            if (reverse)
            {
                this._position = collection.getItems().Count;
            }
        }
        
        public override object Current()
        {
            return this._collection.getItems()[_position];
        }

        public override int Key()
        {
            return this._position;
        }
        
        public override bool MoveNext()
        {
            int updatedPosition = this._position + (this._reverse ? -1 : 1);

            if (updatedPosition >= 0 && updatedPosition < this._collection.getItems().Count)
            {
                this._position = updatedPosition;
                return true;
            }
            else
            {
                return false;
            }
        }
        
        public override void Reset()
        {
            this._position = this._reverse ? this._collection.getItems().Count - 1 : 0;
        }
    }

    // Конкретные Коллекции предоставляют один или несколько методов для
    // получения новых экземпляров итератора, совместимых с классом коллекции.
    class WordsCollection : IteratorAggregate
    {
        List<string> _collection = new List<string>();
        
        bool _direction = false;
        
        public void ReverseDirection()
        {
            _direction = !_direction;
        }
        
        public List<string> getItems()
        {
            return _collection;
        }
        
        public void AddItem(string item)
        {
            this._collection.Add(item);
        }
        
        public override IEnumerator GetEnumerator()
        {
            return new AlphabeticalOrderIterator(this, _direction);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // Клиентский код может знать или не знать о Конкретном Итераторе
            // или классах Коллекций, в зависимости от уровня косвенности,
            // который вы хотите сохранить в своей программе.
            var collection = new WordsCollection();
            collection.AddItem("First");
            collection.AddItem("Second");
            collection.AddItem("Third");

            Console.WriteLine("Straight traversal:");

            foreach (var element in collection)
            {
                Console.WriteLine(element);
            }

            Console.WriteLine("\nReverse traversal:");

            collection.ReverseDirection();

            foreach (var element in collection)
            {
                Console.WriteLine(element);
            }
        }
    }
}
```



### Связь итератора и композита

```cs
// Интерфейс итератора
public interface IOrderIterator
{
    OrderComponent Current { get; }
    bool MoveNext();
    void Reset();
}

// Базовый компонент с поддержкой итерации
public abstract class OrderComponent
{
    public abstract decimal CalculateTotal();
    public virtual void Add(OrderComponent component) => 
        throw new NotImplementedException();
    public virtual void Remove(OrderComponent component) => 
        throw new NotImplementedException();
    
    // Метод для создания итератора
    public virtual IOrderIterator CreateIterator() => 
        new NullIterator();
    
    // Метод для получения всех элементов (для простоты реализации)
    public virtual IEnumerable<OrderComponent> GetChildren() => 
        Enumerable.Empty<OrderComponent>();
}

// Итератор для пустых элементов (листьев)
public class NullIterator : IOrderIterator
{
    public OrderComponent Current => null;
    public bool MoveNext() => false;
    public void Reset() { }
}

// Итератор для композитных объектов
public class CompositeIterator : IOrderIterator
{
    private readonly Stack<IOrderIterator> _stack = new();
    
    public CompositeIterator(IOrderIterator iterator)
    {
        _stack.Push(iterator);
    }
    
    public OrderComponent Current => _stack.Count > 0 ? _stack.Peek().Current : null;
    
    public bool MoveNext()
    {
        if (_stack.Count == 0) return false;
        
        var iterator = _stack.Peek();
        
        if (!iterator.MoveNext())
        {
            _stack.Pop();
            return MoveNext();
        }
        
        var current = iterator.Current;
        if (current is ProductBundle)
        {
            _stack.Push(current.CreateIterator());
        }
        
        return true;
    }
    
    public void Reset()
    {
        _stack.Clear();
    }
}

// Итератор для обхода в глубину (DFS)
public class DepthFirstIterator : IOrderIterator
{
    private readonly List<OrderComponent> _components;
    private int _position = -1;
    
    public DepthFirstIterator(OrderComponent component)
    {
        _components = FlattenComponents(component).ToList();
    }
    
    public OrderComponent Current => 
        _position >= 0 && _position < _components.Count ? _components[_position] : null;
    
    public bool MoveNext()
    {
        _position++;
        return _position < _components.Count;
    }
    
    public void Reset() => _position = -1;
    
    private IEnumerable<OrderComponent> FlattenComponents(OrderComponent component)
    {
        yield return component;
        
        foreach (var child in component.GetChildren())
        {
            foreach (var grandChild in FlattenComponents(child))
            {
                yield return grandChild;
            }
        }
    }
}

// Итератор для обхода в ширину (BFS)
public class BreadthFirstIterator : IOrderIterator
{
    private readonly Queue<OrderComponent> _queue = new();
    private OrderComponent _current;
    
    public BreadthFirstIterator(OrderComponent component)
    {
        _queue.Enqueue(component);
    }
    
    public OrderComponent Current => _current;
    
    public bool MoveNext()
    {
        if (_queue.Count == 0) return false;
        
        _current = _queue.Dequeue();
        
        foreach (var child in _current.GetChildren())
        {
            _queue.Enqueue(child);
        }
        
        return true;
    }
    
    public void Reset()
    {
        _queue.Clear();
        _current = null;
    }
}

// Обновленные классы Product и ProductBundle
public class Product : OrderComponent
{
    public string Name { get; }
    public decimal Price { get; }
    
    public Product(string name, decimal price)
    {
        Name = name;
        Price = price;
    }
    
    public override decimal CalculateTotal() => Price;
    
    public override string ToString() => $"{Name} (${Price})";
}

public class ProductBundle : OrderComponent
{
    private readonly List<OrderComponent> _children = new();
    public string Name { get; }
    
    public ProductBundle(string name) => Name = name;
    
    public override void Add(OrderComponent component) => 
        _children.Add(component);
    
    public override void Remove(OrderComponent component) => 
        _children.Remove(component);
    
    public override decimal CalculateTotal() => 
        _children.Sum(child => child.CalculateTotal());
    
    public override IOrderIterator CreateIterator() => 
        new CompositeIterator(new ListIterator(_children));
    
    public override IEnumerable<OrderComponent> GetChildren() => _children;
    
    public override string ToString() => 
        $"{Name} [${CalculateTotal()}]";
}

// Итератор для списка компонентов
public class ListIterator : IOrderIterator
{
    private readonly List<OrderComponent> _components;
    private int _position = -1;
    
    public ListIterator(List<OrderComponent> components)
    {
        _components = components;
    }
    
    public OrderComponent Current => 
        _position >= 0 && _position < _components.Count ? _components[_position] : null;
    
    public bool MoveNext()
    {
        _position++;
        return _position < _components.Count;
    }
    
    public void Reset() => _position = -1;
}

// Утилитарный класс для расширенных операций с итераторами
public static class OrderIteratorExtensions
{
    public static IEnumerable<OrderComponent> ToEnumerable(this IOrderIterator iterator)
    {
        while (iterator.MoveNext())
        {
            yield return iterator.Current;
        }
    }
    
    public static List<Product> GetAllProducts(this OrderComponent component)
    {
        return component.CreateIterator()
            .ToEnumerable()
            .OfType<Product>()
            .ToList();
    }
    
    public static decimal GetTotalPrice(this OrderComponent component)
    {
        return component.CreateIterator()
            .ToEnumerable()
            .OfType<Product>()
            .Sum(product => product.Price);
    }
}

// Клиентский код
class Program
{
    static void Main()
    {
        // Создаем товары
        var laptop = new Product("MacBook Pro", 2500m);
        var mouse = new Product("Magic Mouse", 99m);
        var keyboard = new Product("Magic Keyboard", 149m);
        var headphones = new Product("AirPods Pro", 249m);
        
        // Создаем комплекты
        var computerSet = new ProductBundle("Computer Set");
        var peripheralSet = new ProductBundle("Peripheral Set");
        var premiumSet = new ProductBundle("Premium Set");
        
        // Строим иерархию
        peripheralSet.Add(mouse);
        peripheralSet.Add(keyboard);
        
        computerSet.Add(laptop);
        computerSet.Add(peripheralSet);
        
        premiumSet.Add(computerSet);
        premiumSet.Add(headphones);
        
        // Демонстрация разных итераторов
        
        Console.WriteLine("=== Обход в глубину (DFS) ===");
        var dfsIterator = new DepthFirstIterator(premiumSet);
        while (dfsIterator.MoveNext())
        {
            var component = dfsIterator.Current;
            Console.WriteLine(component);
        }
        
        Console.WriteLine("\n=== Обход в ширину (BFS) ===");
        var bfsIterator = new BreadthFirstIterator(premiumSet);
        while (bfsIterator.MoveNext())
        {
            var component = bfsIterator.Current;
            Console.WriteLine(component);
        }
        
        Console.WriteLine("\n=== Композитный итератор (только листья) ===");
        var compositeIterator = premiumSet.CreateIterator();
        while (compositeIterator.MoveNext())
        {
            var product = compositeIterator.Current as Product;
            if (product != null)
            {
                Console.WriteLine($"Товар: {product.Name} - ${product.Price}");
            }
        }
        
        Console.WriteLine("\n=== Использование extension методов ===");
        var allProducts = premiumSet.GetAllProducts();
        Console.WriteLine($"Все товары: {string.Join(", ", allProducts.Select(p => p.Name))}");
        Console.WriteLine($"Общая стоимость: ${premiumSet.GetTotalPrice()}");
        
        // Поиск конкретного товара
        Console.WriteLine("\n=== Поиск товара ===");
        var searchIterator = premiumSet.CreateIterator();
        while (searchIterator.MoveNext())
        {
            if (searchIterator.Current is Product product && product.Name.Contains("AirPods"))
            {
                Console.WriteLine($"Найден товар: {product}");
                break;
            }
        }
    }
}
```


```plantuml_class
@startuml
!theme plain

skinparam class {
    BackgroundColor<<Component>> LightBlue
    BackgroundColor<<Leaf>> LightGreen
    BackgroundColor<<Composite>> LightYellow
    BackgroundColor<<Iterator>> LightPink
    BackgroundColor<<ConcreteIterator>> Moccasin
}

package "Composite Pattern" {
    abstract class OrderComponent <<Component>> {
        + CalculateTotal() : decimal
        + Add(component: OrderComponent)
        + Remove(component: OrderComponent)
        + CreateIterator() : IOrderIterator
        + GetChildren() : IEnumerable<OrderComponent>
    }
    
    class Product <<Leaf>> {
        - Name: string
        - Price: decimal
        + CalculateTotal() : decimal
        + ToString() : string
    }
    
    class ProductBundle <<Composite>> {
        - _children: List<OrderComponent>
        - Name: string
        + Add(component: OrderComponent)
        + Remove(component: OrderComponent)
        + CalculateTotal() : decimal
        + CreateIterator() : IOrderIterator
        + GetChildren() : IEnumerable<OrderComponent>
        + ToString() : string
    }
    
    OrderComponent <|-- Product
    OrderComponent <|-- ProductBundle
    ProductBundle *-- OrderComponent : contains
}

package "Iterator Pattern" {
    interface IOrderIterator <<Iterator>> {
        + Current : OrderComponent
        + MoveNext() : bool
        + Reset()
    }
    
    class NullIterator <<ConcreteIterator>> {
        + Current : OrderComponent
        + MoveNext() : bool
        + Reset()
    }
    
    class CompositeIterator <<ConcreteIterator>> {
        - _stack: Stack<IOrderIterator>
        + Current : OrderComponent
        + MoveNext() : bool
        + Reset()
    }
    
    class DepthFirstIterator <<ConcreteIterator>> {
        - _components: List<OrderComponent>
        - _position: int
        + Current : OrderComponent
        + MoveNext() : bool
        + Reset()
        - FlattenComponents(component: OrderComponent) : IEnumerable<OrderComponent>
    }
    
    class BreadthFirstIterator <<ConcreteIterator>> {
        - _queue: Queue<OrderComponent>
        - _current: OrderComponent
        + Current : OrderComponent
        + MoveNext() : bool
        + Reset()
    }
    
    class ListIterator <<ConcreteIterator>> {
        - _components: List<OrderComponent>
        - _position: int
        + Current : OrderComponent
        + MoveNext() : bool
        + Reset()
    }
    
    IOrderIterator <|.. NullIterator
    IOrderIterator <|.. CompositeIterator
    IOrderIterator <|.. DepthFirstIterator
    IOrderIterator <|.. BreadthFirstIterator
    IOrderIterator <|.. ListIterator
}

OrderComponent --> IOrderIterator : creates
ProductBundle --> ListIterator : uses
CompositeIterator --> IOrderIterator : aggregates

note right of OrderComponent::CreateIterator
    Factory method for creating
    appropriate iterator
end note

note right of IOrderIterator::MoveNext
    Core iterator method
    Advances to next element
end note

@enduml
```


```plantuml_sequence
@startuml
!theme plain

actor Client
participant "ProductBundle\n(Premium Set)" as PremiumSet
participant "ProductBundle\n(Computer Set)" as ComputerSet
participant "ProductBundle\n(Peripheral Set)" as PeripheralSet
participant "Product\n(MacBook Pro)" as Laptop
participant "Product\n(Magic Mouse)" as Mouse
participant "Product\n(Magic Keyboard)" as Keyboard
participant "Product\n(AirPods Pro)" as Headphones
participant "CompositeIterator" as Iterator

Client -> PremiumSet: CreateIterator()
activate PremiumSet
PremiumSet -> Iterator: new CompositeIterator()
activate Iterator
return iterator

Client -> Iterator: MoveNext()
activate Iterator

loop while MoveNext() returns true
    Iterator -> PremiumSet: GetChildren()
    activate PremiumSet
    PremiumSet -> ComputerSet: GetChildren()
    activate ComputerSet
    ComputerSet -> Laptop: GetChildren()
    ComputerSet -> PeripheralSet: GetChildren()
    activate PeripheralSet
    PeripheralSet -> Mouse: GetChildren()
    PeripheralSet -> Keyboard: GetChildren()
    return children
    return children
    return children
    
    Iterator -> Client: Current (Product)
    Client -> Iterator: MoveNext()
    
    alt Depth-first traversal logic
        Iterator -> Iterator: Push/Pop iterators from stack
        Iterator -> Iterator: Track position
    end
end

Iterator -> Client: false (end of iteration)
deactivate Iterator

@enduml
```