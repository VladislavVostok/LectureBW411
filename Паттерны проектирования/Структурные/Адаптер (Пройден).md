**Также известен как:** Wrapper, Обёртка, Adapter

##  Суть паттерна

**Адаптер** — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.

##  Проблема

Представьте, что вы делаете приложение для торговли на бирже. Ваше приложение скачивает биржевые котировки из нескольких источников в XML, а затем рисует красивые графики.

В какой-то момент вы решаете улучшить приложение, применив стороннюю библиотеку аналитики. Но вот беда — библиотека поддерживает только формат данных JSON, несовместимый с вашим приложением.

Вы смогли бы переписать библиотеку, чтобы та поддерживала формат XML. Но, во-первых, это может нарушить работу существующего кода, который уже зависит от библиотеки. А во-вторых, у вас может просто не быть доступа к её исходному коду.


## Решение

Вы можете создать _адаптер_. Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту.

При этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого. Например, вы можете обернуть объект, работающий в метрах, адаптером, который бы конвертировал данные в футы.

Адаптеры могут не только переводить данные из одного формата в другой, но и помогать объектам с разными интерфейсами работать сообща. Это работает так:

1. Адаптер имеет интерфейс, который совместим с одним из объектов.
2. Поэтому этот объект может свободно вызывать методы адаптера.
3. Адаптер получает эти вызовы и перенаправляет их второму объекту, но уже в том формате и последовательности, которые понятны второму объекту.

Иногда возможно создать даже _двухсторонний адаптер_, который работал бы в обе стороны.


Таким образом, в приложении биржевых котировок вы могли бы создать класс `XML_To_JSON_Adapter`, который бы оборачивал объект того или иного класса библиотеки аналитики. Ваш код посылал бы адаптеру запросы в формате XML, а адаптер сначала транслировал входящие данные в формат JSON, а затем передавал бы их методам обёрнутого объекта аналитики.


## Аналогия из жизни

Содержимое чемоданов до и после поездки за границу.

Когда вы в первый раз летите за границу, вас может ждать сюрприз при попытке зарядить ноутбук. Стандарты розеток в разных странах отличаются. Ваша европейская зарядка будет бесполезна в США без специального адаптера, позволяющего подключиться к розетке другого типа.


##  Структура

#### Адаптер объектов

**Эта реализация использует агрегацию:** объект адаптера «оборачивает», то есть содержит ссылку на служебный объект. Такой подход работает во всех языках программирования.

![[Pasted image 20250910175951.png]]
1. **Клиент** — это класс, который содержит существующую бизнес-логику программы.
    
2. **Клиентский интерфейс** описывает протокол, через который клиент может работать с другими классами.
    
3. **Сервис** — это какой-то полезный класс, обычно сторонний. Клиент не может использовать этот класс напрямую, так как сервис имеет непонятный ему интерфейс.
    
4. **Адаптер** — это класс, который может одновременно работать и с клиентом, и с сервисом. Он реализует клиентский интерфейс и содержит ссылку на объект сервиса. Адаптер получает вызовы от клиента через методы клиентского интерфейса, а затем переводит их в вызовы методов обёрнутого объекта в правильном формате.
    
5. Работая с адаптером через интерфейс, клиент не привязывается к конкретному классу адаптера. Благодаря этому, вы можете добавлять в программу новые виды адаптеров, независимо от клиентского кода. Это может пригодиться, если интерфейс сервиса вдруг изменится, например, после выхода новой версии сторонней библиотеки.

#### Адаптер классов

**Эта реализация базируется на наследовании:** адаптер наследует оба интерфейса одновременно. Такой подход возможен только в языках, поддерживающих множественное наследование, например, C++, Python.

![[Pasted image 20250910180031.png]]
1. **Адаптер классов** не нуждается во вложенном объекте, так как он может одновременно наследовать и часть существующего класса, и часть сервиса.

##  Применимость

 **Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.**

> Адаптер позволяет создать объект-прокладку, который будет превращать вызовы приложения в формат, понятный стороннему классу.

 **Когда вам нужно использовать несколько существующих подклассов, но в них не хватает какой-то общей функциональности, причём расширить суперкласс вы не можете.**

 Вы могли бы создать ещё один уровень подклассов и добавить в них недостающую функциональность. Но при этом придётся дублировать один и тот же код в обеих ветках подклассов.

Более элегантным решением было бы поместить недостающую функциональность в адаптер и приспособить его для работы с суперклассом. Такой адаптер сможет работать со всеми подклассами иерархии. Это решение будет сильно напоминать паттерн [[Декоратор (Пройден)]].


##  Преимущества

-  Отделяет и скрывает от клиента подробности преобразования различных интерфейсов.

##  Недостатки

- Усложняет код программы из-за введения дополнительных классов.

# Конкретно

**Адаптер** — это структурный паттерн, который позволяет подружить несовместимые объекты.

Адаптер выступает прослойкой между двумя объектами, превращая вызовы одного в вызовы понятные другому.

**Применимость:** Паттерн можно часто встретить в C#-коде, особенно там, где требуется конвертация разных типов данных или совместная работа классов с разными интерфейсами.

**Признаки применения паттерна:** Адаптер получает конвертируемый объект в конструкторе или через параметры своих методов. Методы Адаптера обычно совместимы с интерфейсом одного объекта. Они делегируют вызовы вложенному объекту, превратив перед этим параметры вызова в формат, поддерживаемый вложенным объектом.


### Концептуальный пример:

```cs
namespace Adapter_Concept
{
    public class Program
    {

        // Целевой класс объявляет интерфейс, с которым может работать клиентский код.
        public interface ITarget
        {
            string GetRequest();
        }

        // Адаптируемый класс, который будет содержать какое-то полезное поведение,
        // но его интерфейс не стовместим с существующим кодом. Нуждается в некоторой доработке.
        class Adaptee
        {
            public string GetSpecificRequest() {
                return "Specific request.";
            }
        }

        // Адаптер делает интерфейс Адаптируемого класса совместимым с целевым итерфейсом
        class UpperAdapter : ITarget
        {
            private readonly Adaptee _adaptee;

            public UpperAdapter(Adaptee adaptee) { 
                _adaptee = adaptee;
            }

            public string GetRequest()
            {
                return $"This is '{this._adaptee.GetSpecificRequest()}'".ToUpper();
            }
        }

        class LowerAdapter : ITarget
        {
            private readonly Adaptee _adaptee;

            public LowerAdapter(Adaptee adaptee)
            {
                _adaptee = adaptee;
            }

            public string GetRequest()
            {
                return $"This is '{this._adaptee.GetSpecificRequest()}'".ToLower();
            }
        }

        static void Main(string[] args)
        {
            Adaptee adaptee = new Adaptee();
            ITarget targetUpper = new UpperAdapter(adaptee);
            Console.WriteLine(targetUpper.GetRequest());


            ITarget targetLower = new LowerAdapter(adaptee);
            Console.WriteLine(targetLower.GetRequest());
        }
    }
}
```
