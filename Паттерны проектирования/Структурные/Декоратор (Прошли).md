**Также известен как:** Wrapper, Обёртка, Decorator

##  Суть паттерна

**Декоратор** — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».

![[matrioszki-1571777699.jpg]]

## Проблема

Вы работаете над библиотекой оповещений, которую можно подключать к разнообразным программам, чтобы получать уведомления о важных событиях.

Основой библиотеки является класс `Notifier` с методом `send`, который принимает на вход строку-сообщение и высылает её всем администраторам по электронной почте. Сторонняя программа должна создать и настроить этот объект, указав кому отправлять оповещения, а затем использовать его каждый раз, когда что-то случается.

В какой-то момент стало понятно, что одних email-оповещений пользователям мало. Некоторые из них хотели бы получать извещения о критических проблемах через SMS. Другие хотели бы получать их в виде сообщений Facebook. Корпоративные пользователи хотели бы видеть сообщения в Slack.

![[Pasted image 20250914154050.png]]

Сначала вы добавили каждый из этих типов оповещений в программу, унаследовав их от базового класса `Notifier`. Теперь пользователь выбирал один из типов оповещений, который и использовался в дальнейшем.

Но затем кто-то резонно спросил, почему нельзя выбрать несколько типов оповещений сразу? Ведь если вдруг в вашем доме начался пожар, вы бы хотели получить оповещения по всем каналам, не так ли?

Вы попытались реализовать все возможные комбинации подклассов оповещений. Но после того как вы добавили первый десяток классов, стало ясно, что такой подход невероятно раздувает код программы.

![[Pasted image 20250914154115.png]]

Итак, нужен какой-то другой способ комбинирования поведения объектов, который не приводит к взрыву количества подклассов.

##  Решение

Наследование — это первое, что приходит в голову многим программистам, когда нужно расширить какое-то существующее поведение. Но механизм наследования имеет несколько досадных проблем.

- Он **статичен**. Вы не можете изменить поведение существующего объекта. Для этого вам надо создать новый объект, выбрав другой подкласс.
- Он **не разрешает наследовать поведение нескольких классов одновременно**. Из-за этого вам приходится создавать множество подклассов-комбинаций для получения совмещённого поведения.

Одним из способов обойти эти проблемы является замена наследования _агрегацией_ либо _композицией_ . Это когда один объект _содержит_ ссылку на другой и делегирует ему работу, вместо того чтобы самому _наследовать_ его поведение. Как раз на этом принципе построен паттерн Декоратор.

![[Pasted image 20250914154203.png]]

Декоратор имеет альтернативное название — _обёртка_. Оно более точно описывает суть паттерна: вы помещаете целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.

Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым. Вы можете использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение всех обёрток сразу.

В примере с оповещениями мы оставим в базовом классе простую отправку по электронной почте, а расширенные способы отправки сделаем декораторами.

![[Pasted image 20250914154235.png]]

Сторонняя программа, выступающая клиентом, во время первичной настройки будет заворачивать объект оповещений в те обёртки, которые соответствуют желаемому способу оповещения.

![[Pasted image 20250914154419.png]]
Последняя обёртка в списке и будет тем объектом, с которым клиент будет работать в остальное время. Для остального клиентского кода, по сути, ничего не изменится, ведь все обёртки имеют точно такой же интерфейс, что и базовый класс оповещений.

Таким же образом можно изменять не только способ доставки оповещений, но и форматирование, список адресатов и так далее. К тому же клиент может «дообернуть» объект любыми другими обёртками, когда ему захочется.


## Аналогия из жизни

Одежду можно надевать слоями, получая комбинированный эффект.

Любая одежда — это аналог Декоратора. Применяя Декоратор, вы не меняете первоначальный класс и не создаёте дочерних классов. Так и с одеждой — надевая свитер, вы не перестаёте быть собой, но получаете новое свойство — защиту от холода. Вы можете пойти дальше и надеть сверху ещё один декоратор — плащ, чтобы защититься и от дождя.


##  Структура
![[Pasted image 20250914154645.png]]

1. **Компонент** задаёт общий интерфейс обёрток и оборачиваемых объектов.
    
2. **Конкретный компонент** определяет класс оборачиваемых объектов. Он содержит какое-то базовое поведение, которое потом изменяют декораторы.
    
3. **Базовый декоратор** хранит ссылку на вложенный объект-компонент. Им может быть как конкретный компонент, так и один из конкретных декораторов. Базовый декоратор делегирует все свои операции вложенному объекту. Дополнительное поведение будет жить в конкретных декораторах.
    
4. **Конкретные декораторы** — это различные вариации декораторов, которые содержат добавочное поведение. Оно выполняется до или после вызова аналогичного поведения обёрнутого объекта.
    
5. **Клиент** может оборачивать простые компоненты и декораторы в другие декораторы, работая со всеми объектами через общий интерфейс компонентов.


## Конкретно

Декоратор - это структурный паттерн, который позволяет добавлять объектам новое поведение на лету, помещая из в объекты-обёртки.

Декоратор позволяет оборачивать объекты бесчисленное количество раз благодаря тому, что и обёртки, и реальные объекты  имеют общий интерфейс.

**Применимость:** Паттерн применяется в работе с потоками данных.

**Признаки применения паттерна:** Декоратор можно распознать по создающим методам, которые принимают в параметрах объекты того же абстрактного типа или интерфейса, что и текущий класс.


### Концептуальный пример:

```cs

```


## Решение задачи

```uml
@startuml
skinparam class {
    BackgroundColor White
    BorderColor Black
    ArrowColor Black
}

interface IDataSource {
    + WriteData(data: string)
    + ReadData(): string
}

class FileDataSource {
    - _filename: string
    + FileDataSource(filename: string)
    + WriteData(data: string)
    + ReadData(): string
}

abstract class DataSourceDecorator {
    # _wrappee: IDataSource
    + DataSourceDecorator(source: IDataSource)
    + WriteData(data: string)
    + ReadData(): string
}

class EncryptionDecorator {
    - _key: byte[]
    + EncryptionDecorator(source: IDataSource)
    + WriteData(data: string)
    + ReadData(): string
    - Encrypt(plainText: string): string
    - Decrypt(cipherText: string): string
}

class CompressionDecorator {
    + CompressionDecorator(source: IDataSource)
    + WriteData(data: string)
    + ReadData(): string
    - Compress(data: string): string
    - Decompress(compressedData: string): string
}

class SalaryManager {
    - _source: IDataSource
    - _salaryRecords: string
    + SalaryManager(source: IDataSource)
    + Load(): string
    + Save()
}

class Application {
    + DumbUsageExample()
}

class ApplicationConfigurator {
    + ConfigurationExample(enabledEncryption: bool, enabledCompression: bool)
}

IDataSource <|.. FileDataSource
IDataSource <|.. DataSourceDecorator
DataSourceDecorator <|-- EncryptionDecorator
DataSourceDecorator <|-- CompressionDecorator

DataSourceDecorator o-- IDataSource

SalaryManager --> IDataSource
Application --> IDataSource
ApplicationConfigurator --> IDataSource
ApplicationConfigurator --> SalaryManager

note right of IDataSource
    <<interface>>
    Общий интерфейс для всех
    компонентов и декораторов
end note

note right of DataSourceDecorator
    Абстрактный базовый класс
    для всех декораторов
end note
@enduml
```